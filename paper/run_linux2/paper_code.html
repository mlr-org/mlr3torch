<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 13:45:56 UTC&quot;
</code></pre>
<pre><code class="language-r">options(mlr3torch.cache = TRUE)
lgr::get_logger('mlr3')$set_threshold('warn')
library(&quot;mlr3&quot;)
set.seed(42)
task &lt;- tsk(&quot;mtcars&quot;)
learner &lt;- lrn(&quot;regr.rpart&quot;)
split &lt;- partition(task, ratio = 2/3)
learner$train(task, split$train)
pred &lt;- learner$predict(task, split$test)
pred$score(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.736051
</code></pre>
<pre><code class="language-r">library(&quot;mlr3pipelines&quot;)
graph_learner &lt;- as_learner(po(&quot;pca&quot;) %&gt;&gt;% lrn(&quot;regr.rpart&quot;))

resampling &lt;- rsmp(&quot;cv&quot;, folds = 3)
rr &lt;- resample(task, graph_learner, resampling)
rr$aggregate(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.274766
</code></pre>
<pre><code class="language-r">library(&quot;torch&quot;)
torch_manual_seed(42)
x &lt;- torch_tensor(1, device = &quot;cpu&quot;)
w &lt;- torch_tensor(2, requires_grad = TRUE, device = &quot;cpu&quot;)
y &lt;- w * x
y$backward()
w$grad
</code></pre>
<pre><code>## torch_tensor
##  1
## [ CPUFloatType{1} ]
</code></pre>
<pre><code class="language-r">library(&quot;mlr3torch&quot;)
mnist &lt;- tsk(&quot;mnist&quot;)
mnist
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (70000x2): MNIST Digit Classification ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: label
</code></pre>
<pre><code>## Dataset &lt;mnist&gt; (~12 MB) will be downloaded and processed if not already available.
## Downloading &lt;mnist&gt; ...
## Processing &lt;mnist&gt;...
## Dataset &lt;mnist&gt; downloaded and extracted successfully.
## Dataset &lt;mnist&gt; loaded with 60000 images.
## Dataset &lt;mnist&gt; loaded with 10000 images.
</code></pre>
<pre><code>## • Target classes: 1 (11%), 7 (10%), 3 (10%), 2 (10%), 9 (10%), 0 (10%), 6 (10%), 8 (10%), 4 (10%), 5 (9%)
## • Properties: multiclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">rows &lt;- mnist$data(1:2)
rows
</code></pre>
<pre><code>##     label           image
##    &lt;fctr&gt;   &lt;lazy_tensor&gt;
## 1:      5 &lt;tnsr[1x28x28]&gt;
## 2:      0 &lt;tnsr[1x28x28]&gt;
</code></pre>
<pre><code class="language-r">str(materialize(rows$image))
</code></pre>
<pre><code>## List of 2
##  $ :Float [1:1, 1:28, 1:28]
##  $ :Float [1:1, 1:28, 1:28]
</code></pre>
<pre><code class="language-r">po_flat &lt;- po(&quot;trafo_reshape&quot;, shape = c(-1, 28 * 28))
mnist_flat &lt;- po_flat$train(list(mnist))[[1L]]
mnist_flat$head(2)
</code></pre>
<pre><code>##     label         image
##    &lt;fctr&gt; &lt;lazy_tensor&gt;
## 1:      5   &lt;tnsr[784]&gt;
## 2:      0   &lt;tnsr[784]&gt;
</code></pre>
<pre><code class="language-r">mlp &lt;- lrn(&quot;classif.mlp&quot;,
 loss = t_loss(&quot;cross_entropy&quot;),
 optimizer = t_opt(&quot;adamw&quot;, lr = 0.001),
 callbacks = t_clbk(&quot;history&quot;))

mlp$param_set$set_values(
  neurons = c(100, 200), activation = torch::nn_relu,
  p = 0.3, opt.weight_decay = 0.01, measures_train = msr(&quot;classif.logloss&quot;),
  epochs = 10, batch_size = 32, device = &quot;cpu&quot;)

mlp$configure(predict_type = &quot;prob&quot;)

mlp$train(mnist_flat, row_ids = 1:1001)

mlp$model$network
</code></pre>
<pre><code>## An `nn_module` containing 100,710 parameters.
## 
## ── Modules ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • 0: &lt;nn_linear&gt; #78,500 parameters
## • 1: &lt;nn_relu&gt; #0 parameters
## • 2: &lt;nn_dropout&gt; #0 parameters
## • 3: &lt;nn_linear&gt; #20,200 parameters
## • 4: &lt;nn_relu&gt; #0 parameters
## • 5: &lt;nn_dropout&gt; #0 parameters
## • 6: &lt;nn_linear&gt; #2,010 parameters
</code></pre>
<pre><code class="language-r">head(mlp$model$callbacks$history, n = 2)
</code></pre>
<pre><code>##    epoch train.classif.logloss
##    &lt;num&gt;                 &lt;num&gt;
## 1:     1              4.504909
## 2:     2              1.270763
</code></pre>
<pre><code class="language-r">pred &lt;- mlp$predict(mnist_flat, row_ids = 1001:1100)
pred$score(msr(&quot;classif.ce&quot;))
</code></pre>
<pre><code>## classif.ce 
##       0.18
</code></pre>
<pre><code class="language-r">pth &lt;- tempfile()
mlp$marshal()
saveRDS(mlp, pth)
mlp2 &lt;- readRDS(pth)
mlp2$unmarshal()

set_validate(mlp, validate = 0.3)

nn_simple &lt;- nn_module(&quot;nn_simple&quot;,
  initialize = function(d_in, d_latent, d_out) {
    self$linear1 = nn_linear(d_in, d_latent)
    self$activation = nn_relu()
    self$linear2 = nn_linear(d_latent, d_out)
  },
  forward = function(x) {
    x = self$linear1(x)
    x = self$activation(x)
    self$linear2(x)
  }
)

net &lt;- nn_simple(10, 100, 1)

net(torch_randn(1, 10))
</code></pre>
<pre><code>## torch_tensor
## 0.01 *
## -9.4603
## [ CPUFloatType{1,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">module_graph &lt;- po(&quot;module_1&quot;, module = nn_linear(10, 100)) %&gt;&gt;%
 po(&quot;module_2&quot;, module = nn_relu()) %&gt;&gt;%
 po(&quot;module_3&quot;, module = nn_linear(100, 1))

net &lt;- nn_graph(module_graph, shapes_in = list(module_1.input = c(NA, 10)))
net(torch_randn(2, 10))
</code></pre>
<pre><code>## torch_tensor
## -0.1218
## -0.0636
## [ CPUFloatType{2,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">graph &lt;- po(&quot;torch_ingress_ltnsr&quot;) %&gt;&gt;%
  nn(&quot;linear&quot;, out_features = 10) %&gt;&gt;% nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;head&quot;)

md &lt;- graph$train(mnist_flat)[[1L]]
md
</code></pre>
<pre><code>## &lt;ModelDescriptor: 4 ops&gt;
## * Ingress:  torch_ingress_ltnsr.input: [(NA,784)]
## * Task:  mnist [classif]
## * Callbacks:  N/A
## * Optimizer:  N/A
## * Loss:  N/A
## * pointer:  head.output [(NA,10)]
</code></pre>
<pre><code class="language-r">graph &lt;- graph %&gt;&gt;%
  po(&quot;torch_loss&quot;, t_loss(&quot;cross_entropy&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.001))

graph &lt;- graph %&gt;&gt;% po(&quot;torch_model_classif&quot;, epochs = 10, batch_size = 16)

glrn &lt;- as_learner(graph)
glrn$train(mnist_flat, row_ids = 1:1000)

path_lin &lt;- nn(&quot;linear_1&quot;)
path_nonlin &lt;- nn(&quot;linear_2&quot;) %&gt;&gt;% nn(&quot;relu&quot;)

residual_layer &lt;- list(path_lin, path_nonlin) %&gt;&gt;% nn(&quot;merge_sum&quot;)

path_num &lt;- po(&quot;select_1&quot;, selector = selector_type(&quot;numeric&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_num&quot;, d_token = 10)
path_categ &lt;- po(&quot;select_2&quot;, selector = selector_type(&quot;factor&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_categ&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_categ&quot;, d_token = 10)

graph &lt;- list(path_num, path_categ) %&gt;&gt;% nn(&quot;merge_cat&quot;, dim = 2)

blocks &lt;- nn(&quot;block&quot;, residual_layer, n_blocks = 5)

nn_winsorized_mse &lt;- nn_module(c(&quot;nn_winsorized_mse&quot;, &quot;nn_loss&quot;),
  initialize = function(max_loss) {
    self$max_loss &lt;- max_loss
  },
  forward = function(input, target) {
    torch_clamp(nnf_mse_loss(input, target), max = self$max_loss)
  }
)
tloss &lt;- as_torch_loss(nn_winsorized_mse)
tloss
</code></pre>
<pre><code>## &lt;TorchLoss:nn_winsorized_mse&gt; nn_winsorized_mse
## * Generator: nn_winsorized_mse
## * Parameters: list()
## * Packages: torch,mlr3torch
## * Task Types: classif,regr
</code></pre>
<pre><code class="language-r">gradient_clipper &lt;- torch_callback(&quot;gradient_clipper&quot;,
  initialize = function(max_norm, norm_type) {
    self$norms &lt;- numeric()
    self$max_norm &lt;- max_norm
    self$norm_type &lt;- norm_type
  },
  on_after_backward = function() {
    norm &lt;- nn_utils_clip_grad_norm_(self$ctx$network$parameters,
      self$max_norm, self$norm_type)
    self$norms &lt;- c(self$norms, norm$item())
  },
  state_dict = function() {
    self$norms
  },
  load_state_dict = function(state_dict) {
    self$norms = state_dict
  }
)

nn_ffn &lt;- nn_module(&quot;nn_ffn&quot;,
  initialize = function(task, latent_dim, n_layers) {
    dims &lt;- c(task$n_features, rep(latent_dim, n_layers),
      length(task$class_names))
    modules &lt;- unlist(lapply(seq_len(length(dims) - 1), function(i) {
      if (i &lt; length(dims) - 1) {
        list(nn_linear(dims[i], dims[i + 1]), nn_relu())
      } else {
        list(nn_linear(dims[i], dims[i + 1]))
      }
    }), recursive = FALSE)
    self$network &lt;- do.call(nn_sequential, modules)
  },
  forward = function(x) self$network(x)
)

num_input &lt;- list(x = ingress_num())
num_input
</code></pre>
<pre><code>## $x
## Ingress: Task[selector_type(c(&quot;numeric&quot;, &quot;integer&quot;))] --&gt; Tensor()
</code></pre>
<pre><code class="language-r">lrn_ffn &lt;- lrn(&quot;classif.module&quot;,
  module_generator = nn_ffn,
  ingress_tokens = num_input,
  latent_dim = 100, n_layers = 5)

task &lt;- tsk(&quot;mtcars&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskRegr&gt; (32x11): Motor Trends ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: mpg
## • Properties: -
## • Features (10):
##   • dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt
</code></pre>
<pre><code class="language-r">ingress &lt;- po(&quot;torch_ingress_num&quot;)

block &lt;- nn(&quot;linear&quot;, out_features = 32) %&gt;&gt;%
  ppl(&quot;branch&quot;, list(relu = nn(&quot;relu&quot;), sigmoid = nn(&quot;sigmoid&quot;))) %&gt;&gt;%
  nn(&quot;dropout&quot;)

architecture &lt;- nn(&quot;block&quot;, block) %&gt;&gt;% nn(&quot;head&quot;)

config &lt;- po(&quot;torch_loss&quot;, loss = t_loss(&quot;mse&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, optimizer = t_opt(&quot;adamw&quot;))

model &lt;- po(&quot;torch_model_regr&quot;, device = &quot;cpu&quot;, batch_size = 512)

pipeline &lt;- ingress %&gt;&gt;%
  architecture %&gt;&gt;% config %&gt;&gt;% model
learner &lt;- as_learner(pipeline)
learner$id &lt;- &quot;custom_nn&quot;

library(&quot;mlr3tuning&quot;)
</code></pre>
<pre><code>## Loading required package: paradox
</code></pre>
<pre><code class="language-r">learner$param_set$set_values(
  block.linear.out_features = to_tune(20, 500),
  block.n_blocks = to_tune(1, 5),
  block.branch.selection = to_tune(c(&quot;relu&quot;, &quot;sigmoid&quot;)),
  block.dropout.p = to_tune(0.1, 0.9),
  torch_optimizer.lr = to_tune(10^-4, 10^-1, logscale = TRUE))

set_validate(learner, &quot;test&quot;)

learner$param_set$set_values(
  torch_model_regr.patience = 5,
  torch_model_regr.measures_valid = msr(&quot;regr.mse&quot;),
  torch_model_regr.epochs = to_tune(upper = 100, internal = TRUE))

library(&quot;mlr3tuning&quot;)
ti &lt;- tune(
  tuner = tnr(&quot;random_search&quot;),
  resampling = rsmp(&quot;holdout&quot;),
  measure = msr(&quot;internal_valid_score&quot;, minimize = TRUE),
  learner = learner,
  term_evals = 30,
  task = task)
pvals &lt;- ti$result_learner_param_vals[2:6]
cat(paste(&quot;*&quot;, names(pvals), &quot;=&quot;, pvals,
 collapse = &quot;\n&quot;), &quot;\n&quot;)
</code></pre>
<pre><code>## * block.linear.out_features = 248
## * block.branch.selection = sigmoid
## * block.dropout.p = 0.861211954243481
## * torch_optimizer.lr = 0.00310737353560635
## * torch_model_regr.epochs = 44
</code></pre>
<pre><code class="language-r">library(&quot;torchdatasets&quot;)
dogs_vs_cats_dataset(&quot;data&quot;, download = TRUE)
</code></pre>
<pre><code>## &lt;dataset&gt;
##   Public:
##     .getitem: function (i) 
##     .length: function () 
##     classes: dog cat
##     clone: function (deep = FALSE) 
##     images: data/dogs-vs-cats/train/cat.0.jpg data/dogs-vs-cats/trai ...
##     initialize: function (root, split = &quot;train&quot;, download = FALSE, ..., transform = NULL, 
##     load_state_dict: function (x, ..., .refer_to_state_dict = FALSE) 
##     state_dict: function () 
##     target_transform: NULL
##     targets: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2  ...
##     transform: NULL
</code></pre>
<pre><code class="language-r">ds &lt;- torch::dataset(&quot;dogs_vs_cats&quot;,
  initialize = function(pths) {
    self$pths &lt;- pths
  },
  .getitem = function(i) {
    image &lt;- torchvision::base_loader(self$pths[i])
    list(image = torch_tensor(image)$permute(c(3, 1, 2)))
  },
  .length = function() {
    length(self$pths)
  }
)

paths &lt;- list.files(file.path(&quot;data&quot;, &quot;dogs-vs-cats/train&quot;),
  full.names = TRUE)
dogs_vs_cats &lt;- ds(paths)

lt &lt;- as_lazy_tensor(dogs_vs_cats, list(image = NULL))

labels &lt;- ifelse(grepl(&quot;dog\\.\\d+\\.jpg&quot;, paths), &quot;dog&quot;, &quot;cat&quot;)
table(labels)
</code></pre>
<pre><code>## labels
##   cat   dog 
## 12500 12500
</code></pre>
<pre><code class="language-r">tbl &lt;- data.table(image = lt, class = labels)
task &lt;- as_task_classif(tbl, target = &quot;class&quot;, id = &quot;dogs_vs_cats&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (25000x2) ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: class
## • Target classes: cat (positive class, 50%), dog (50%)
## • Properties: twoclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">augment &lt;- po(&quot;augment_random_vertical_flip&quot;, p = 0.5)

preprocess &lt;- po(&quot;trafo_resize&quot;, size = c(224, 224))

unfreezer &lt;- t_clbk(&quot;unfreeze&quot;,
  starting_weights = select_name(c(&quot;fc.weight&quot;, &quot;fc.bias&quot;)),
  unfreeze = data.table(epoch = 3, weights = select_all()))

resnet &lt;- lrn(&quot;classif.resnet18&quot;,
  pretrained = TRUE, epochs = 5, device = &quot;cpu&quot;, batch_size = 32,
  opt.lr = 1e-4, measures_valid = msr(&quot;classif.acc&quot;),
  callbacks = list(unfreezer, t_clbk(&quot;history&quot;)))

learner &lt;- as_learner(augment %&gt;&gt;% preprocess %&gt;&gt;% resnet)
learner$id &lt;- &quot;resnet&quot;
set_validate(learner, 1 / 3)
learner$train(task, c(12400:12600))
</code></pre>
<pre><code>## Model weights for &lt;resnet18&gt; (~45 MB) will be downloaded and processed if not
## already available.
</code></pre>
<pre><code class="language-r">learner$model$classif.resnet18$model$callbacks$history
</code></pre>
<pre><code>##    epoch valid.classif.acc
##    &lt;num&gt;             &lt;num&gt;
## 1:     1         0.4179104
## 2:     2         0.4477612
## 3:     3         0.8955224
## 4:     4         0.8955224
## 5:     5         0.9253731
</code></pre>
<pre><code class="language-r">task &lt;- tsk(&quot;melanoma&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (32701x5): Melanoma Classification ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: outcome
## • Target classes: malignant (positive class, 2%), benign (98%)
## • Properties: twoclass, groups
## • Features (4):
##   • fct (2): anatom_site_general_challenge, sex
##   • int (1): age_approx
##   • lt (1): image
## • Groups: patient_id
</code></pre>
<pre><code class="language-r">table(task$truth())
</code></pre>
<pre><code>## 
## malignant    benign 
##       581     32120
</code></pre>
<pre><code class="language-r">task$missings(&quot;age_approx&quot;)
</code></pre>
<pre><code>## age_approx 
##         44
</code></pre>
<pre><code class="language-r">block_ffn &lt;- nn(&quot;linear&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;dropout&quot;)
path_tabular &lt;- po(&quot;select_1&quot;,
    selector = selector_type(c(&quot;integer&quot;, &quot;factor&quot;))) %&gt;&gt;%
  po(&quot;imputehist&quot;) %&gt;&gt;%
  po(&quot;encode&quot;, method = &quot;one-hot&quot;) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;block_1&quot;, block = block_ffn, n_blocks = 3)

path_image &lt;- po(&quot;select_2&quot;, selector = selector_name(&quot;image&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_ltnsr&quot;, shape = c(NA, 3, 128, 128)) %&gt;&gt;%
  nn(&quot;conv2d_1&quot;, out_channels = 16, kernel_size = 7, stride = 2,
    padding = 3) %&gt;&gt;%
  nn(&quot;batch_norm2d_1&quot;) %&gt;&gt;%
  nn(&quot;relu_1&quot;) %&gt;&gt;%
  nn(&quot;max_pool2d_1&quot;, kernel_size = 3, stride = 2, padding = 1) %&gt;&gt;%
  nn(&quot;conv2d_2&quot;, out_channels = 32, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_2&quot;) %&gt;&gt;%
  nn(&quot;relu_2&quot;) %&gt;&gt;%
  nn(&quot;conv2d_3&quot;, out_channels = 64, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_3&quot;) %&gt;&gt;%
  nn(&quot;relu_3&quot;) %&gt;&gt;%
  nn(&quot;flatten&quot;)

architecture &lt;- list(path_tabular, path_image) %&gt;&gt;%
  nn(&quot;merge_cat&quot;) %&gt;&gt;% nn(&quot;linear_1&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu_4&quot;) %&gt;&gt;% nn(&quot;dropout_2&quot;) %&gt;&gt;% nn(&quot;head&quot;)

model &lt;- architecture %&gt;&gt;%
  po(&quot;torch_loss&quot;,
    t_loss(&quot;cross_entropy&quot;, class_weight = torch_tensor(10))) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.0005)) %&gt;&gt;%
  po(&quot;torch_model_classif&quot;, epochs = 4, batch_size = 32, device = &quot;cpu&quot;,
    predict_type = &quot;prob&quot;)

preprocessing &lt;- po(&quot;classbalancing&quot;, ratio = 4, reference = &quot;minor&quot;,
    adjust = &quot;minor&quot;) %&gt;&gt;%
  po(&quot;augment_random_horizontal_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_vertical_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_crop&quot;, size = c(128, 128), pad_if_needed = TRUE)
glrn &lt;- as_learner(preprocessing %&gt;&gt;% model)

library(&quot;mlr3viz&quot;)
glrn$id &lt;- &quot;multimodal&quot;
task_subset &lt;- task$clone(deep = TRUE)
subset &lt;- partition(task_subset, ratio = 0.1)$train
task_subset$filter(subset)
rr &lt;- resample(task_subset, glrn, rsmp(&quot;holdout&quot;))
autoplot(rr, type = &quot;roc&quot;)
</code></pre>
<pre><code>## Warning in ggplot2::fortify(object, raw_curves = raw_curves, reduce_points = reduce_points): Arguments in `...` must be used.
## ✖ Problematic argument:
## • raw_curves = raw_curves
## ℹ Did you misspell an argument name?
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-1" /></p>
<pre><code class="language-r">saveRDS(.Last.value, here::here(&quot;paper&quot;, &quot;roc.rds&quot;))
sessionInfo()
</code></pre>
<pre><code>## R version 4.5.1 (2025-06-13)
## Platform: x86_64-pc-linux-gnu
## Running under: Ubuntu 24.04.3 LTS
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 
## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## time zone: Etc/UTC
## tzcode source: system (glibc)
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] mlr3viz_0.10.1      torchdatasets_0.3.1 mlr3tuning_1.4.0   
## [4] paradox_1.0.1       mlr3torch_0.3.2     torch_0.16.3       
## [7] future_1.67.0       mlr3pipelines_0.9.0 mlr3_1.2.0         
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6         xfun_0.54            ggplot2_4.0.0       
##  [4] processx_3.8.6       callr_3.7.6          vctrs_0.6.5         
##  [7] tools_4.5.1          ps_1.9.1             safetensors_0.2.0   
## [10] curl_7.0.0           parallel_4.5.1       tibble_3.3.0        
## [13] pkgconfig_2.0.3      data.table_1.17.8    checkmate_2.3.3     
## [16] RColorBrewer_1.1-3   S7_0.2.0             assertthat_0.2.1    
## [19] uuid_1.2-1           lifecycle_1.0.4      compiler_4.5.1      
## [22] farver_2.1.2         stringr_1.6.0        precrec_0.14.5      
## [25] codetools_0.2-20     bbotk_1.7.1          pillar_1.11.1       
## [28] crayon_1.5.3         rpart_4.1.24         parallelly_1.45.1   
## [31] digest_0.6.37        stringi_1.8.7        listenv_0.10.0      
## [34] labeling_0.4.3       mlr3measures_1.1.0   rprojroot_2.1.1     
## [37] grid_4.5.1           here_1.0.2           cli_3.6.5           
## [40] magrittr_2.0.4       future.apply_1.20.0  withr_3.0.2         
## [43] scales_1.4.0         backports_1.5.0      rappdirs_0.3.3      
## [46] bit64_4.6.0-1        globals_0.18.0       jpeg_0.1-11         
## [49] bit_4.6.0            evaluate_1.0.5       knitr_1.50          
## [52] torchvision_0.8.0    viridisLite_0.4.2    mlr3misc_0.19.0     
## [55] rlang_1.1.6          Rcpp_1.1.0           zeallot_0.2.0       
## [58] glue_1.8.0           palmerpenguins_0.1.1 coro_1.1.0          
## [61] jsonlite_2.0.0       lgr_0.5.0            R6_2.6.1            
## [64] fs_1.6.6
</code></pre>
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 13:59:09 UTC&quot;
</code></pre>
</div>
</body>
</html>
