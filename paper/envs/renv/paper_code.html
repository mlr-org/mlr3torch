<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 13:27:36 CET&quot;
</code></pre>
<pre><code class="language-r">options(mlr3torch.cache = TRUE)
lgr::get_logger('mlr3')$set_threshold('warn')
library(&quot;mlr3&quot;)
set.seed(42)
task &lt;- tsk(&quot;mtcars&quot;)
learner &lt;- lrn(&quot;regr.rpart&quot;)
split &lt;- partition(task, ratio = 2/3)
learner$train(task, split$train)
pred &lt;- learner$predict(task, split$test)
pred$score(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.736051
</code></pre>
<pre><code class="language-r">library(&quot;mlr3pipelines&quot;)
graph_learner &lt;- as_learner(po(&quot;pca&quot;) %&gt;&gt;% lrn(&quot;regr.rpart&quot;))

resampling &lt;- rsmp(&quot;cv&quot;, folds = 3)
rr &lt;- resample(task, graph_learner, resampling)
rr$aggregate(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.274766
</code></pre>
<pre><code class="language-r">library(&quot;torch&quot;)
torch_manual_seed(42)
x &lt;- torch_tensor(1, device = &quot;cpu&quot;)
w &lt;- torch_tensor(2, requires_grad = TRUE, device = &quot;cpu&quot;)
y &lt;- w * x
y$backward()
w$grad
</code></pre>
<pre><code>## torch_tensor
##  1
## [ CPUFloatType{1} ]
</code></pre>
<pre><code class="language-r">library(&quot;mlr3torch&quot;)
mnist &lt;- tsk(&quot;mnist&quot;)
mnist
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (70000x2): MNIST Digit Classification ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: label
## • Target classes: 1 (11%), 7 (10%), 3 (10%), 2 (10%), 9 (10%), 0 (10%), 6 (10%), 8 (10%), 4 (10%), 5 (9%)
## • Properties: multiclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">rows &lt;- mnist$data(1:2)
rows
</code></pre>
<pre><code>##     label           image
##    &lt;fctr&gt;   &lt;lazy_tensor&gt;
## 1:      5 &lt;tnsr[1x28x28]&gt;
## 2:      0 &lt;tnsr[1x28x28]&gt;
</code></pre>
<pre><code class="language-r">str(materialize(rows$image))
</code></pre>
<pre><code>## List of 2
##  $ :Float [1:1, 1:28, 1:28]
##  $ :Float [1:1, 1:28, 1:28]
</code></pre>
<pre><code class="language-r">po_flat &lt;- po(&quot;trafo_reshape&quot;, shape = c(-1, 28 * 28))
mnist_flat &lt;- po_flat$train(list(mnist))[[1L]]
mnist_flat$head(2)
</code></pre>
<pre><code>##     label         image
##    &lt;fctr&gt; &lt;lazy_tensor&gt;
## 1:      5   &lt;tnsr[784]&gt;
## 2:      0   &lt;tnsr[784]&gt;
</code></pre>
<pre><code class="language-r">mlp &lt;- lrn(&quot;classif.mlp&quot;,
 loss = t_loss(&quot;cross_entropy&quot;),
 optimizer = t_opt(&quot;adamw&quot;, lr = 0.001),
 callbacks = t_clbk(&quot;history&quot;))

mlp$param_set$set_values(
  neurons = c(100, 200), activation = torch::nn_relu,
  p = 0.3, opt.weight_decay = 0.01, measures_train = msr(&quot;classif.logloss&quot;),
  epochs = 10, batch_size = 32, device = &quot;cpu&quot;)

mlp$configure(predict_type = &quot;prob&quot;)

mlp$train(mnist_flat, row_ids = 1:1001)

mlp$model$network
</code></pre>
<pre><code>## An `nn_module` containing 100,710 parameters.
## 
## ── Modules ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • 0: &lt;nn_linear&gt; #78,500 parameters
## • 1: &lt;nn_relu&gt; #0 parameters
## • 2: &lt;nn_dropout&gt; #0 parameters
## • 3: &lt;nn_linear&gt; #20,200 parameters
## • 4: &lt;nn_relu&gt; #0 parameters
## • 5: &lt;nn_dropout&gt; #0 parameters
## • 6: &lt;nn_linear&gt; #2,010 parameters
</code></pre>
<pre><code class="language-r">head(mlp$model$callbacks$history, n = 2)
</code></pre>
<pre><code>##    epoch train.classif.logloss
##    &lt;num&gt;                 &lt;num&gt;
## 1:     1              4.504887
## 2:     2              1.270129
</code></pre>
<pre><code class="language-r">pred &lt;- mlp$predict(mnist_flat, row_ids = 1001:1100)
pred$score(msr(&quot;classif.ce&quot;))
</code></pre>
<pre><code>## classif.ce 
##       0.19
</code></pre>
<pre><code class="language-r">pth &lt;- tempfile()
mlp$marshal()
saveRDS(mlp, pth)
mlp2 &lt;- readRDS(pth)
mlp2$unmarshal()

set_validate(mlp, validate = 0.3)

nn_simple &lt;- nn_module(&quot;nn_simple&quot;,
  initialize = function(d_in, d_latent, d_out) {
    self$linear1 = nn_linear(d_in, d_latent)
    self$activation = nn_relu()
    self$linear2 = nn_linear(d_latent, d_out)
  },
  forward = function(x) {
    x = self$linear1(x)
    x = self$activation(x)
    self$linear2(x)
  }
)

net &lt;- nn_simple(10, 100, 1)

net(torch_randn(1, 10))
</code></pre>
<pre><code>## torch_tensor
## 0.01 *
## -9.4603
## [ CPUFloatType{1,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">module_graph &lt;- po(&quot;module_1&quot;, module = nn_linear(10, 100)) %&gt;&gt;%
 po(&quot;module_2&quot;, module = nn_relu()) %&gt;&gt;%
 po(&quot;module_3&quot;, module = nn_linear(100, 1))

net &lt;- nn_graph(module_graph, shapes_in = list(module_1.input = c(NA, 10)))
net(torch_randn(2, 10))
</code></pre>
<pre><code>## torch_tensor
## -0.1218
## -0.0636
## [ CPUFloatType{2,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">graph &lt;- po(&quot;torch_ingress_ltnsr&quot;) %&gt;&gt;%
  nn(&quot;linear&quot;, out_features = 10) %&gt;&gt;% nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;head&quot;)

md &lt;- graph$train(mnist_flat)[[1L]]
md
</code></pre>
<pre><code>## &lt;ModelDescriptor: 4 ops&gt;
## * Ingress:  torch_ingress_ltnsr.input: [(NA,784)]
## * Task:  mnist [classif]
## * Callbacks:  N/A
## * Optimizer:  N/A
## * Loss:  N/A
## * pointer:  head.output [(NA,10)]
</code></pre>
<pre><code class="language-r">graph &lt;- graph %&gt;&gt;%
  po(&quot;torch_loss&quot;, t_loss(&quot;cross_entropy&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.001))

graph &lt;- graph %&gt;&gt;% po(&quot;torch_model_classif&quot;, epochs = 10, batch_size = 16)

glrn &lt;- as_learner(graph)
glrn$train(mnist_flat, row_ids = 1:1000)

path_lin &lt;- nn(&quot;linear_1&quot;)
path_nonlin &lt;- nn(&quot;linear_2&quot;) %&gt;&gt;% nn(&quot;relu&quot;)

residual_layer &lt;- list(path_lin, path_nonlin) %&gt;&gt;% nn(&quot;merge_sum&quot;)

path_num &lt;- po(&quot;select_1&quot;, selector = selector_type(&quot;numeric&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_num&quot;, d_token = 10)
path_categ &lt;- po(&quot;select_2&quot;, selector = selector_type(&quot;factor&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_categ&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_categ&quot;, d_token = 10)

graph &lt;- list(path_num, path_categ) %&gt;&gt;% nn(&quot;merge_cat&quot;, dim = 2)

blocks &lt;- nn(&quot;block&quot;, residual_layer, n_blocks = 5)

nn_winsorized_mse &lt;- nn_module(c(&quot;nn_winsorized_mse&quot;, &quot;nn_loss&quot;),
  initialize = function(max_loss) {
    self$max_loss &lt;- max_loss
  },
  forward = function(input, target) {
    torch_clamp(nnf_mse_loss(input, target), max = self$max_loss)
  }
)
tloss &lt;- as_torch_loss(nn_winsorized_mse)
tloss
</code></pre>
<pre><code>## &lt;TorchLoss:nn_winsorized_mse&gt; nn_winsorized_mse
## * Generator: nn_winsorized_mse
## * Parameters: list()
## * Packages: torch,mlr3torch
## * Task Types: classif,regr
</code></pre>
<pre><code class="language-r">gradient_clipper &lt;- torch_callback(&quot;gradient_clipper&quot;,
  initialize = function(max_norm, norm_type) {
    self$norms &lt;- numeric()
    self$max_norm &lt;- max_norm
    self$norm_type &lt;- norm_type
  },
  on_after_backward = function() {
    norm &lt;- nn_utils_clip_grad_norm_(self$ctx$network$parameters,
      self$max_norm, self$norm_type)
    self$norms &lt;- c(self$norms, norm$item())
  },
  state_dict = function() {
    self$norms
  },
  load_state_dict = function(state_dict) {
    self$norms = state_dict
  }
)

nn_ffn &lt;- nn_module(&quot;nn_ffn&quot;,
  initialize = function(task, latent_dim, n_layers) {
    dims &lt;- c(task$n_features, rep(latent_dim, n_layers),
      length(task$class_names))
    modules &lt;- unlist(lapply(seq_len(length(dims) - 1), function(i) {
      if (i &lt; length(dims) - 1) {
        list(nn_linear(dims[i], dims[i + 1]), nn_relu())
      } else {
        list(nn_linear(dims[i], dims[i + 1]))
      }
    }), recursive = FALSE)
    self$network &lt;- do.call(nn_sequential, modules)
  },
  forward = function(x) self$network(x)
)

num_input &lt;- list(x = ingress_num())
num_input
</code></pre>
<pre><code>## $x
## Ingress: Task[selector_type(c(&quot;numeric&quot;, &quot;integer&quot;))] --&gt; Tensor()
</code></pre>
<pre><code class="language-r">lrn_ffn &lt;- lrn(&quot;classif.module&quot;,
  module_generator = nn_ffn,
  ingress_tokens = num_input,
  latent_dim = 100, n_layers = 5)

task &lt;- tsk(&quot;mtcars&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskRegr&gt; (32x11): Motor Trends ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: mpg
## • Properties: -
## • Features (10):
##   • dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt
</code></pre>
<pre><code class="language-r">ingress &lt;- po(&quot;torch_ingress_num&quot;)

block &lt;- nn(&quot;linear&quot;, out_features = 32) %&gt;&gt;%
  ppl(&quot;branch&quot;, list(relu = nn(&quot;relu&quot;), sigmoid = nn(&quot;sigmoid&quot;))) %&gt;&gt;%
  nn(&quot;dropout&quot;)

architecture &lt;- nn(&quot;block&quot;, block) %&gt;&gt;% nn(&quot;head&quot;)

config &lt;- po(&quot;torch_loss&quot;, loss = t_loss(&quot;mse&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, optimizer = t_opt(&quot;adamw&quot;))

model &lt;- po(&quot;torch_model_regr&quot;, device = &quot;cpu&quot;, batch_size = 512)

pipeline &lt;- ingress %&gt;&gt;%
  architecture %&gt;&gt;% config %&gt;&gt;% model
learner &lt;- as_learner(pipeline)
learner$id &lt;- &quot;custom_nn&quot;

library(&quot;mlr3tuning&quot;)
</code></pre>
<pre><code>## Loading required package: paradox
</code></pre>
<pre><code class="language-r">learner$param_set$set_values(
  block.linear.out_features = to_tune(20, 500),
  block.n_blocks = to_tune(1, 5),
  block.branch.selection = to_tune(c(&quot;relu&quot;, &quot;sigmoid&quot;)),
  block.dropout.p = to_tune(0.1, 0.9),
  torch_optimizer.lr = to_tune(10^-4, 10^-1, logscale = TRUE))

set_validate(learner, &quot;test&quot;)

learner$param_set$set_values(
  torch_model_regr.patience = 5,
  torch_model_regr.measures_valid = msr(&quot;regr.mse&quot;),
  torch_model_regr.epochs = to_tune(upper = 100, internal = TRUE))

library(&quot;mlr3mbo&quot;)
ti &lt;- tune(
  tuner = tnr(&quot;mbo&quot;),
  resampling = rsmp(&quot;holdout&quot;),
  measure = msr(&quot;internal_valid_score&quot;, minimize = TRUE),
  learner = learner,
  term_evals = 30,
  task = task)
pvals &lt;- ti$result_learner_param_vals[2:6]
cat(paste(&quot;*&quot;, names(pvals), &quot;=&quot;, pvals,
 collapse = &quot;\n&quot;), &quot;\n&quot;)
</code></pre>
<pre><code>## * block.linear.out_features = 464
## * block.branch.selection = sigmoid
## * block.dropout.p = 0.375850691832602
## * torch_optimizer.lr = 0.00145715908440791
## * torch_model_regr.epochs = 100
</code></pre>
<pre><code class="language-r">library(&quot;torchdatasets&quot;)
dogs_vs_cats_dataset(&quot;data&quot;, download = TRUE)
</code></pre>
<pre><code>## &lt;dataset&gt;
##   Public:
##     .getitem: function (i) 
##     .length: function () 
##     classes: dog cat
##     clone: function (deep = FALSE) 
##     images: data/dogs-vs-cats/train/cat.0.jpg data/dogs-vs-cats/trai ...
##     initialize: function (root, split = &quot;train&quot;, download = FALSE, ..., transform = NULL, 
##     load_state_dict: function (x, ..., .refer_to_state_dict = FALSE) 
##     state_dict: function () 
##     target_transform: NULL
##     targets: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2  ...
##     transform: NULL
</code></pre>
<pre><code class="language-r">ds &lt;- torch::dataset(&quot;dogs_vs_cats&quot;,
  initialize = function(pths) {
    self$pths &lt;- pths
  },
  .getitem = function(i) {
    image &lt;- torchvision::base_loader(self$pths[i])
    list(image = torch_tensor(image)$permute(c(3, 1, 2)))
  },
  .length = function() {
    length(self$pths)
  }
)

paths &lt;- list.files(file.path(&quot;data&quot;, &quot;dogs-vs-cats/train&quot;),
  full.names = TRUE)
dogs_vs_cats &lt;- ds(paths)

lt &lt;- as_lazy_tensor(dogs_vs_cats, list(image = NULL))

labels &lt;- ifelse(grepl(&quot;dog\\.\\d+\\.jpg&quot;, paths), &quot;dog&quot;, &quot;cat&quot;)
table(labels)
</code></pre>
<pre><code>## labels
##   cat   dog 
## 12500 12500
</code></pre>
<pre><code class="language-r">tbl &lt;- data.table(image = lt, class = labels)
task &lt;- as_task_classif(tbl, target = &quot;class&quot;, id = &quot;dogs_vs_cats&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (25000x2) ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: class
## • Target classes: cat (positive class, 50%), dog (50%)
## • Properties: twoclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">augment &lt;- po(&quot;augment_random_vertical_flip&quot;, p = 0.5)

preprocess &lt;- po(&quot;trafo_resize&quot;, size = c(224, 224))

unfreezer &lt;- t_clbk(&quot;unfreeze&quot;,
  starting_weights = select_name(c(&quot;fc.weight&quot;, &quot;fc.bias&quot;)),
  unfreeze = data.table(epoch = 3, weights = select_all()))

resnet &lt;- lrn(&quot;classif.resnet18&quot;,
  pretrained = TRUE, epochs = 5, device = &quot;cpu&quot;, batch_size = 32,
  opt.lr = 1e-4, measures_valid = msr(&quot;classif.acc&quot;),
  callbacks = list(unfreezer, t_clbk(&quot;history&quot;)))

learner &lt;- as_learner(augment %&gt;&gt;% preprocess %&gt;&gt;% resnet)
learner$id &lt;- &quot;resnet&quot;
set_validate(learner, 1 / 3)
learner$train(task, c(12400:12600))
</code></pre>
<pre><code>## Model weights for &lt;resnet18&gt; (~45 MB) will be downloaded and processed if not
## already available.
</code></pre>
<pre><code>## Error in `runtime_error()` at torchvision/R/models-resnet.R:247:5:
## ! Corrupt file! Delete the file in ~/Library/Caches/torch/resnet18.pth and try again.
## This happened in PipeOp classif.resnet18's $train()
</code></pre>
<pre><code class="language-r">learner$model$classif.resnet18$model$callbacks$history
</code></pre>
<pre><code>## NULL
</code></pre>
<pre><code class="language-r">task &lt;- tsk(&quot;melanoma&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (32701x5): Melanoma Classification ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: outcome
## • Target classes: malignant (positive class, 2%), benign (98%)
## • Properties: twoclass, groups
## • Features (4):
##   • fct (2): anatom_site_general_challenge, sex
##   • int (1): age_approx
##   • lt (1): image
## • Groups: patient_id
</code></pre>
<pre><code class="language-r">table(task$truth())
</code></pre>
<pre><code>## 
## malignant    benign 
##       581     32120
</code></pre>
<pre><code class="language-r">task$missings(&quot;age_approx&quot;)
</code></pre>
<pre><code>## age_approx 
##         44
</code></pre>
<pre><code class="language-r">block_ffn &lt;- nn(&quot;linear&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;dropout&quot;)
path_tabular &lt;- po(&quot;select_1&quot;,
    selector = selector_type(c(&quot;integer&quot;, &quot;factor&quot;))) %&gt;&gt;%
  po(&quot;imputehist&quot;) %&gt;&gt;%
  po(&quot;encode&quot;, method = &quot;one-hot&quot;) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;block_1&quot;, block = block_ffn, n_blocks = 3)

path_image &lt;- po(&quot;select_2&quot;, selector = selector_name(&quot;image&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_ltnsr&quot;, shape = c(NA, 3, 128, 128)) %&gt;&gt;%
  nn(&quot;conv2d_1&quot;, out_channels = 16, kernel_size = 7, stride = 2,
    padding = 3) %&gt;&gt;%
  nn(&quot;batch_norm2d_1&quot;) %&gt;&gt;%
  nn(&quot;relu_1&quot;) %&gt;&gt;%
  nn(&quot;max_pool2d_1&quot;, kernel_size = 3, stride = 2, padding = 1) %&gt;&gt;%
  nn(&quot;conv2d_2&quot;, out_channels = 32, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_2&quot;) %&gt;&gt;%
  nn(&quot;relu_2&quot;) %&gt;&gt;%
  nn(&quot;conv2d_3&quot;, out_channels = 64, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_3&quot;) %&gt;&gt;%
  nn(&quot;relu_3&quot;) %&gt;&gt;%
  nn(&quot;flatten&quot;)

architecture &lt;- list(path_tabular, path_image) %&gt;&gt;%
  nn(&quot;merge_cat&quot;) %&gt;&gt;% nn(&quot;linear_1&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu_4&quot;) %&gt;&gt;% nn(&quot;dropout_2&quot;) %&gt;&gt;% nn(&quot;head&quot;)

model &lt;- architecture %&gt;&gt;%
  po(&quot;torch_loss&quot;,
    t_loss(&quot;cross_entropy&quot;, class_weight = torch_tensor(10))) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.0005)) %&gt;&gt;%
  po(&quot;torch_model_classif&quot;, epochs = 4, batch_size = 32, device = &quot;cpu&quot;,
    predict_type = &quot;prob&quot;)

preprocessing &lt;- po(&quot;classbalancing&quot;, ratio = 4, reference = &quot;minor&quot;,
    adjust = &quot;minor&quot;) %&gt;&gt;%
  po(&quot;augment_random_horizontal_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_vertical_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_crop&quot;, size = c(128, 128), pad_if_needed = TRUE)
glrn &lt;- as_learner(preprocessing %&gt;&gt;% model)

library(&quot;mlr3viz&quot;)
glrn$id &lt;- &quot;multimodal&quot;
task_subset &lt;- task$clone(deep = TRUE)
subset &lt;- partition(task_subset, ratio = 0.1)$train
task_subset$filter(subset)
rr &lt;- resample(task_subset, glrn, rsmp(&quot;holdout&quot;))
autoplot(rr, type = &quot;roc&quot;)
</code></pre>
<pre><code>## Warning in ggplot2::fortify(object, raw_curves = raw_curves, reduce_points = reduce_points): Arguments in `...` must be used.
## ✖ Problematic argument:
## • raw_curves = raw_curves
## ℹ Did you misspell an argument name?
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-1" /></p>
<pre><code class="language-r">saveRDS(.Last.value, here::here(&quot;paper&quot;, &quot;roc.rds&quot;))
sessionInfo()
</code></pre>
<pre><code>## R version 4.5.1 (2025-06-13)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sequoia 15.2
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: Europe/Berlin
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
##  [1] mlr3viz_0.10.1      torchdatasets_0.3.1 mlr3mbo_0.3.3      
##  [4] mlr3tuning_1.4.0    paradox_1.0.1       mlr3torch_0.3.2    
##  [7] torch_0.16.3        future_1.67.0       mlr3pipelines_0.9.0
## [10] mlr3_1.2.0         
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6         ggplot2_4.0.0        xfun_0.54           
##  [4] processx_3.8.6       lattice_0.22-7       callr_3.7.6         
##  [7] vctrs_0.6.5          tools_4.5.1          ps_1.9.1            
## [10] safetensors_0.2.0    parallel_4.5.1       tibble_3.3.0        
## [13] pkgconfig_2.0.3      Matrix_1.7-3         data.table_1.17.8   
## [16] checkmate_2.3.3      RColorBrewer_1.1-3   S7_0.2.0            
## [19] assertthat_0.2.1     uuid_1.2-1           lifecycle_1.0.4     
## [22] farver_2.1.2         compiler_4.5.1       stringr_1.6.0       
## [25] precrec_0.14.5       codetools_0.2-20     bbotk_1.7.1         
## [28] pillar_1.11.1        crayon_1.5.3         rpart_4.1.24        
## [31] parallelly_1.45.1    digest_0.6.37        stringi_1.8.7       
## [34] listenv_0.10.0       labeling_0.4.3       mlr3measures_1.1.0  
## [37] rprojroot_2.1.1      grid_4.5.1           here_1.0.2          
## [40] cli_3.6.5            magrittr_2.0.4       future.apply_1.20.0 
## [43] withr_3.0.2          scales_1.4.0         backports_1.5.0     
## [46] rappdirs_0.3.3       bit64_4.6.0-1        spacefillr_0.4.0    
## [49] globals_0.18.0       jpeg_0.1-11          bit_4.6.0           
## [52] ranger_0.17.0        evaluate_1.0.5       knitr_1.50          
## [55] torchvision_0.8.0    viridisLite_0.4.2    mlr3misc_0.19.0     
## [58] rlang_1.1.6          Rcpp_1.1.0           zeallot_0.2.0       
## [61] glue_1.8.0           renv_1.1.5           palmerpenguins_0.1.1
## [64] coro_1.1.0           jsonlite_2.0.0       lgr_0.5.0           
## [67] R6_2.6.1             fs_1.6.6             mlr3learners_0.13.0
</code></pre>
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 13:33:10 CET&quot;
</code></pre>
</div>
</body>
</html>
