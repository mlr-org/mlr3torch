<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r"># Some setup code
Sys.time()
</code></pre>
<pre><code>## [1] &quot;2026-01-29 17:27:24 CET&quot;
</code></pre>
<pre><code class="language-r">options(mlr3torch.cache = TRUE)
lgr::get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
library(&quot;mlr3&quot;)
set.seed(42)
task &lt;- tsk(&quot;mtcars&quot;)
learner &lt;- lrn(&quot;regr.rpart&quot;)
split &lt;- partition(task, ratio = 2/3)
learner$train(task, split$train)
pred &lt;- learner$predict(task, split$test)
pred$score(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.736051
</code></pre>
<pre><code class="language-r"># mlr3pipelines
library(&quot;mlr3pipelines&quot;)
graph_learner &lt;- as_learner(po(&quot;pca&quot;) %&gt;&gt;% lrn(&quot;regr.rpart&quot;))

resampling &lt;- rsmp(&quot;cv&quot;, folds = 3)
rr &lt;- resample(task, graph_learner, resampling)
rr$aggregate(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.274766
</code></pre>
<pre><code class="language-r"># torch
library(&quot;torch&quot;)
torch_manual_seed(42)
x &lt;- torch_tensor(1, device = &quot;cpu&quot;)
w &lt;- torch_tensor(2, requires_grad = TRUE, device = &quot;cpu&quot;)
y &lt;- w * x
y$backward()
w$grad
</code></pre>
<pre><code>## torch_tensor
##  1
## [ CPUFloatType{1} ]
</code></pre>
<pre><code class="language-r"># 3. Building Blocks

# 3.1 Data representation
library(&quot;mlr3torch&quot;)
mnist &lt;- tsk(&quot;mnist&quot;)
mnist
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (70000x2): MNIST Digit Classification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: label
## • Target classes: 1 (11%), 7 (10%), 3 (10%), 2 (10%), 9 (10%), 0 (10%), 6 (10%), 8 (10%), 4 (10%), 5 (9%)
## • Properties: multiclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">rows &lt;- mnist$data(1:2)
rows
</code></pre>
<pre><code>##     label           image
##    &lt;fctr&gt;   &lt;lazy_tensor&gt;
## 1:      5 &lt;tnsr[1x28x28]&gt;
## 2:      0 &lt;tnsr[1x28x28]&gt;
</code></pre>
<pre><code class="language-r">str(materialize(rows$image))
</code></pre>
<pre><code>## List of 2
##  $ :Float [1:1, 1:28, 1:28]
##  $ :Float [1:1, 1:28, 1:28]
</code></pre>
<pre><code class="language-r">po_flat &lt;- po(&quot;trafo_reshape&quot;, shape = c(-1, 28 * 28))
mnist_flat &lt;- po_flat$train(list(mnist))[[1L]]
mnist_flat$head(2)
</code></pre>
<pre><code>##     label         image
##    &lt;fctr&gt; &lt;lazy_tensor&gt;
## 1:      5   &lt;tnsr[784]&gt;
## 2:      0   &lt;tnsr[784]&gt;
</code></pre>
<pre><code class="language-r"># 3.2 The LearnerTorch class

mlp &lt;- lrn(&quot;classif.mlp&quot;,
 loss = t_loss(&quot;cross_entropy&quot;),
 optimizer = t_opt(&quot;adamw&quot;, lr = 0.001),
 callbacks = t_clbk(&quot;history&quot;))

mlp$param_set$set_values(
  neurons = c(100, 200), activation = torch::nn_relu,
  p = 0.3, opt.weight_decay = 0.01, measures_train = msr(&quot;classif.logloss&quot;),
  epochs = 10, batch_size = 32, device = &quot;cpu&quot;)

mlp$configure(predict_type = &quot;prob&quot;)

mlp$train(mnist_flat, row_ids = 1:1000)

mlp$model$network
</code></pre>
<pre><code>## An `nn_module` containing 100,710 parameters.
## 
## ── Modules ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • 0: &lt;nn_linear&gt; #78,500 parameters
## • 1: &lt;nn_relu&gt; #0 parameters
## • 2: &lt;nn_dropout&gt; #0 parameters
## • 3: &lt;nn_linear&gt; #20,200 parameters
## • 4: &lt;nn_relu&gt; #0 parameters
## • 5: &lt;nn_dropout&gt; #0 parameters
## • 6: &lt;nn_linear&gt; #2,010 parameters
</code></pre>
<pre><code class="language-r">head(mlp$model$callbacks$history, n = 2)
</code></pre>
<pre><code>##    epoch train.classif.logloss
##    &lt;num&gt;                 &lt;num&gt;
## 1:     1              4.266896
## 2:     2              1.296983
</code></pre>
<pre><code class="language-r">pred &lt;- mlp$predict(mnist_flat, row_ids = 1001:1100)
pred$score(msr(&quot;classif.ce&quot;))
</code></pre>
<pre><code>## classif.ce 
##       0.19
</code></pre>
<pre><code class="language-r">pth &lt;- tempfile()
mlp$marshal()
saveRDS(mlp, pth)
mlp2 &lt;- readRDS(pth)
mlp2$unmarshal()

set_validate(mlp, validate = 0.3)

# 3.3 Neural networks as Graphs

nn_simple &lt;- nn_module(&quot;nn_simple&quot;,
  initialize = function(d_in, d_latent, d_out) {
    self$linear1 = nn_linear(d_in, d_latent)
    self$activation = nn_relu()
    self$linear2 = nn_linear(d_latent, d_out)
  },
  forward = function(x) {
    x = self$linear1(x)
    x = self$activation(x)
    self$linear2(x)
  }
)

net &lt;- nn_simple(10, 100, 1)

net(torch_randn(1, 10))
</code></pre>
<pre><code>## torch_tensor
## 0.01 *
## -9.4603
## [ CPUFloatType{1,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">module_graph &lt;- po(&quot;module_1&quot;, module = nn_linear(10, 100)) %&gt;&gt;%
 po(&quot;module_2&quot;, module = nn_relu()) %&gt;&gt;%
 po(&quot;module_3&quot;, module = nn_linear(100, 1))

net &lt;- nn_graph(module_graph, shapes_in = list(module_1.input = c(NA, 10)))
net(torch_randn(2, 10))
</code></pre>
<pre><code>## torch_tensor
## -0.1218
## -0.0636
## [ CPUFloatType{2,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">graph &lt;- po(&quot;torch_ingress_ltnsr&quot;) %&gt;&gt;%
  nn(&quot;linear&quot;, out_features = 10) %&gt;&gt;% nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;head&quot;)

md &lt;- graph$train(mnist_flat)[[1L]]
md
</code></pre>
<pre><code>## &lt;ModelDescriptor: 4 ops&gt;
## * Ingress:  torch_ingress_ltnsr.input: [(NA,784)]
## * Task:  mnist [classif]
## * Callbacks:  N/A
## * Optimizer:  N/A
## * Loss:  N/A
## * pointer:  head.output [(NA,10)]
</code></pre>
<pre><code class="language-r">graph &lt;- graph %&gt;&gt;%
  po(&quot;torch_loss&quot;, t_loss(&quot;cross_entropy&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.001))

graph &lt;- graph %&gt;&gt;% po(&quot;torch_model_classif&quot;, epochs = 10, batch_size = 16)

glrn &lt;- as_learner(graph)
glrn$train(mnist_flat, row_ids = 1:1000)

path_lin &lt;- nn(&quot;linear_1&quot;)
path_nonlin &lt;- nn(&quot;linear_2&quot;) %&gt;&gt;% nn(&quot;relu&quot;)

residual_layer &lt;- list(path_lin, path_nonlin) %&gt;&gt;% nn(&quot;merge_sum&quot;)

path_num &lt;- po(&quot;select_1&quot;, selector = selector_type(&quot;numeric&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_num&quot;, d_token = 10)
path_categ &lt;- po(&quot;select_2&quot;, selector = selector_type(&quot;factor&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_categ&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_categ&quot;, d_token = 10)

graph &lt;- list(path_num, path_categ) %&gt;&gt;% nn(&quot;merge_cat&quot;, dim = 2)

blocks &lt;- nn(&quot;block&quot;, residual_layer, n_blocks = 5)

# 4. Extending the package

# 4.1 Loss and optimizer

nn_winsorized_mse &lt;- nn_module(c(&quot;nn_winsorized_mse&quot;, &quot;nn_loss&quot;),
  initialize = function(max_loss) {
    self$max_loss &lt;- max_loss
  },
  forward = function(input, target) {
    torch_clamp(nnf_mse_loss(input, target), max = self$max_loss)
  }
)
tloss &lt;- as_torch_loss(nn_winsorized_mse)
tloss
</code></pre>
<pre><code>## &lt;TorchLoss:nn_winsorized_mse&gt; nn_winsorized_mse
## * Generator: nn_winsorized_mse
## * Parameters: list()
## * Packages: torch,mlr3torch
## * Task Types: classif,regr
</code></pre>
<pre><code class="language-r"># 4.2 Callbacks

gradient_clipper &lt;- torch_callback(&quot;gradient_clipper&quot;,
  initialize = function(max_norm, norm_type) {
    self$norms &lt;- numeric()
    self$max_norm &lt;- max_norm
    self$norm_type &lt;- norm_type
  },
  on_after_backward = function() {
    norm &lt;- nn_utils_clip_grad_norm_(self$ctx$network$parameters,
      self$max_norm, self$norm_type)
    self$norms &lt;- c(self$norms, norm$item())
  },
  state_dict = function() {
    self$norms
  },
  load_state_dict = function(state_dict) {
    self$norms = state_dict
  }
)

# 4.3 Learners and task types

nn_ffn &lt;- nn_module(&quot;nn_ffn&quot;,
  initialize = function(task, latent_dim, n_layers) {
    dims &lt;- c(task$n_features, rep(latent_dim, n_layers),
      length(task$class_names))
    modules &lt;- unlist(lapply(seq_len(length(dims) - 1), function(i) {
      if (i &lt; length(dims) - 1) {
        list(nn_linear(dims[i], dims[i + 1]), nn_relu())
      } else {
        list(nn_linear(dims[i], dims[i + 1]))
      }
    }), recursive = FALSE)
    self$network &lt;- do.call(nn_sequential, modules)
  },
  forward = function(x) self$network(x)
)

num_input &lt;- list(x = ingress_num())
num_input
</code></pre>
<pre><code>## $x
## Ingress: Task[selector_type(c(&quot;numeric&quot;, &quot;integer&quot;))] --&gt; Tensor()
</code></pre>
<pre><code class="language-r">lrn_ffn &lt;- lrn(&quot;classif.module&quot;,
  module_generator = nn_ffn,
  ingress_tokens = num_input,
  latent_dim = 100, n_layers = 5)


# 5. Use cases

# 5.1 Simple neural architecture search

task &lt;- tsk(&quot;mtcars&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskRegr&gt; (32x11): Motor Trends ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: mpg
## • Properties: -
## • Features (10):
##   • dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt
</code></pre>
<pre><code class="language-r">ingress &lt;- po(&quot;torch_ingress_num&quot;)

block &lt;- nn(&quot;linear&quot;, out_features = 32) %&gt;&gt;%
  ppl(&quot;branch&quot;, list(relu = nn(&quot;relu&quot;), sigmoid = nn(&quot;sigmoid&quot;))) %&gt;&gt;%
  nn(&quot;dropout&quot;)

architecture &lt;- nn(&quot;block&quot;, block) %&gt;&gt;% nn(&quot;head&quot;)

config &lt;- po(&quot;torch_loss&quot;, loss = t_loss(&quot;mse&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, optimizer = t_opt(&quot;adamw&quot;))

model &lt;- po(&quot;torch_model_regr&quot;, device = &quot;cpu&quot;, batch_size = 32)

pipeline &lt;- ingress %&gt;&gt;%
  architecture %&gt;&gt;% config %&gt;&gt;% model
learner &lt;- as_learner(pipeline)
learner$id &lt;- &quot;custom_nn&quot;

library(&quot;mlr3tuning&quot;)
</code></pre>
<pre><code>## Loading required package: paradox
</code></pre>
<pre><code class="language-r">learner$param_set$set_values(
  block.linear.out_features = to_tune(20, 500),
  block.n_blocks = to_tune(1, 5),
  block.branch.selection = to_tune(c(&quot;relu&quot;, &quot;sigmoid&quot;)),
  block.dropout.p = to_tune(0.1, 0.9),
  torch_optimizer.lr = to_tune(10^-4, 10^-1, logscale = TRUE))

set_validate(learner, &quot;test&quot;)

learner$param_set$set_values(
  torch_model_regr.patience = 5,
  torch_model_regr.measures_valid = msr(&quot;regr.mse&quot;),
  torch_model_regr.epochs = to_tune(upper = 100, internal = TRUE))

ti &lt;- tune(
  tuner = tnr(&quot;random_search&quot;),
  resampling = rsmp(&quot;holdout&quot;),
  measure = msr(&quot;internal_valid_score&quot;, minimize = TRUE),
  learner = learner,
  term_evals = 30,
  task = task)
pvals &lt;- ti$result_learner_param_vals[1:6]
cat(paste(&quot;*&quot;, names(pvals), &quot;=&quot;, pvals,
 collapse = &quot;\n&quot;), &quot;\n&quot;)
</code></pre>
<pre><code>## * block.n_blocks = 4
## * block.linear.out_features = 248
## * block.branch.selection = sigmoid
## * block.dropout.p = 0.861211954243481
## * torch_optimizer.lr = 0.00310737353560635
## * torch_model_regr.epochs = 44
</code></pre>
<pre><code class="language-r"># 5.2 Fine-tuning an image network

library(&quot;torchdatasets&quot;)
dogs_vs_cats_dataset(&quot;data&quot;, download = TRUE)
</code></pre>
<pre><code>## &lt;dataset&gt;
##   Public:
##     .getitem: function (i) 
##     .length: function () 
##     classes: dog cat
##     clone: function (deep = FALSE) 
##     images: data/dogs-vs-cats/train/cat.0.jpg data/dogs-vs-cats/trai ...
##     initialize: function (root, split = &quot;train&quot;, download = FALSE, ..., transform = NULL, 
##     load_state_dict: function (x, ..., .refer_to_state_dict = FALSE) 
##     state_dict: function () 
##     target_transform: NULL
##     targets: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2  ...
##     transform: NULL
</code></pre>
<pre><code class="language-r">ds &lt;- torch::dataset(&quot;dogs_vs_cats&quot;,
  initialize = function(pths) {
    self$pths &lt;- pths
  },
  .getitem = function(i) {
    image &lt;- torchvision::base_loader(self$pths[i])
    list(image = torch_tensor(image)$permute(c(3, 1, 2)))
  },
  .length = function() {
    length(self$pths)
  }
)

paths &lt;- list.files(file.path(&quot;data&quot;, &quot;dogs-vs-cats/train&quot;),
  full.names = TRUE)
dogs_vs_cats &lt;- ds(paths)

lt &lt;- as_lazy_tensor(dogs_vs_cats, list(image = NULL))

labels &lt;- ifelse(grepl(&quot;dog\\.\\d+\\.jpg&quot;, paths), &quot;dog&quot;, &quot;cat&quot;)
table(labels)
</code></pre>
<pre><code>## labels
##   cat   dog 
## 12500 12500
</code></pre>
<pre><code class="language-r">tbl &lt;- data.table(image = lt, class = labels)
task &lt;- as_task_classif(tbl, target = &quot;class&quot;, id = &quot;dogs_vs_cats&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (25000x2) ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: class
## • Target classes: cat (positive class, 50%), dog (50%)
## • Properties: twoclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">augment &lt;- po(&quot;augment_random_vertical_flip&quot;, p = 0.5)

preprocess &lt;- po(&quot;trafo_resize&quot;, size = c(224, 224))

unfreezer &lt;- t_clbk(&quot;unfreeze&quot;,
  starting_weights = select_name(c(&quot;fc.weight&quot;, &quot;fc.bias&quot;)),
  unfreeze = data.table(epoch = 3, weights = select_all()))

resnet &lt;- lrn(&quot;classif.resnet18&quot;,
  pretrained = TRUE, epochs = 5, device = &quot;cpu&quot;, batch_size = 32,
  opt.lr = 1e-4, measures_valid = msr(&quot;classif.acc&quot;),
  callbacks = list(unfreezer, t_clbk(&quot;history&quot;)))

learner &lt;- as_learner(augment %&gt;&gt;% preprocess %&gt;&gt;% resnet)
learner$id &lt;- &quot;resnet&quot;
set_validate(learner, 1 / 3)
learner$train(task, c(12400:12600))
</code></pre>
<pre><code>## Model weights for &lt;resnet18&gt; (~45 MB) will be downloaded and processed if not
## already available.
</code></pre>
<pre><code class="language-r">learner$model$classif.resnet18$model$callbacks$history
</code></pre>
<pre><code>##    epoch valid.classif.acc
##    &lt;num&gt;             &lt;num&gt;
## 1:     1         0.4179104
## 2:     2         0.4626866
## 3:     3         0.8955224
## 4:     4         0.8955224
## 5:     5         0.9253731
</code></pre>
<pre><code class="language-r"># 5.3 Multi-modal data

task &lt;- tsk(&quot;melanoma&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (32701x5): Melanoma Classification ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: outcome
## • Target classes: malignant (positive class, 2%), benign (98%)
## • Properties: twoclass, groups
## • Features (4):
##   • fct (2): anatom_site_general_challenge, sex
##   • int (1): age_approx
##   • lt (1): image
## • Groups: patient_id
</code></pre>
<pre><code class="language-r">table(task$truth())
</code></pre>
<pre><code>## 
## malignant    benign 
##       581     32120
</code></pre>
<pre><code class="language-r">task$missings(&quot;age_approx&quot;)
</code></pre>
<pre><code>## age_approx 
##         44
</code></pre>
<pre><code class="language-r">block_ffn &lt;- nn(&quot;linear&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;dropout&quot;)
path_tabular &lt;- po(&quot;select_1&quot;,
    selector = selector_type(c(&quot;integer&quot;, &quot;factor&quot;))) %&gt;&gt;%
  po(&quot;imputehist&quot;) %&gt;&gt;%
  po(&quot;encode&quot;, method = &quot;one-hot&quot;) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;block_1&quot;, block = block_ffn, n_blocks = 3)

path_image &lt;- po(&quot;select_2&quot;, selector = selector_name(&quot;image&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_ltnsr&quot;, shape = c(NA, 3, 128, 128)) %&gt;&gt;%
  nn(&quot;conv2d_1&quot;, out_channels = 16, kernel_size = 7, stride = 2,
    padding = 3) %&gt;&gt;%
  nn(&quot;batch_norm2d_1&quot;) %&gt;&gt;%
  nn(&quot;relu_1&quot;) %&gt;&gt;%
  nn(&quot;max_pool2d_1&quot;, kernel_size = 3, stride = 2, padding = 1) %&gt;&gt;%
  nn(&quot;conv2d_2&quot;, out_channels = 32, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_2&quot;) %&gt;&gt;%
  nn(&quot;relu_2&quot;) %&gt;&gt;%
  nn(&quot;conv2d_3&quot;, out_channels = 64, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_3&quot;) %&gt;&gt;%
  nn(&quot;relu_3&quot;) %&gt;&gt;%
  nn(&quot;flatten&quot;)

architecture &lt;- list(path_tabular, path_image) %&gt;&gt;%
  nn(&quot;merge_cat&quot;) %&gt;&gt;% nn(&quot;linear_1&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu_4&quot;) %&gt;&gt;% nn(&quot;dropout_2&quot;) %&gt;&gt;% nn(&quot;head&quot;)

model &lt;- architecture %&gt;&gt;%
  po(&quot;torch_loss&quot;,
    t_loss(&quot;cross_entropy&quot;, class_weight = torch_tensor(10))) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.0005)) %&gt;&gt;%
  po(&quot;torch_model_classif&quot;, epochs = 4, batch_size = 32, device = &quot;cpu&quot;,
    predict_type = &quot;prob&quot;)

preprocessing &lt;- po(&quot;classbalancing&quot;, ratio = 4, reference = &quot;minor&quot;,
    adjust = &quot;minor&quot;) %&gt;&gt;%
  po(&quot;augment_random_horizontal_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_vertical_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_crop&quot;, size = c(128, 128), pad_if_needed = TRUE)
glrn &lt;- as_learner(preprocessing %&gt;&gt;% model)

library(&quot;mlr3viz&quot;)
glrn$id &lt;- &quot;multimodal&quot;
task_subset &lt;- task$clone(deep = TRUE)
subset &lt;- partition(task_subset, ratio = 0.1)$train
task_subset$filter(subset)
rr &lt;- resample(task_subset, glrn, rsmp(&quot;holdout&quot;))
plt &lt;- autoplot(rr, type = &quot;roc&quot;)

library(&quot;ggplot2&quot;)
plt = plt +
  theme(
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12)
  )
print(plt)
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-1" /></p>
<pre><code class="language-r">ggsave(here::here(&quot;roc.png&quot;), plt, width = 4, height = 4, dpi = 300)
Sys.time()
</code></pre>
<pre><code>## [1] &quot;2026-01-29 17:36:21 CET&quot;
</code></pre>
<pre><code class="language-r">sessionInfo()
</code></pre>
<pre><code>## R version 4.5.1 (2025-06-13)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sequoia 15.2
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: Europe/Berlin
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
##  [1] ggplot2_4.0.0       mlr3viz_0.10.1.9000 torchdatasets_0.3.1
##  [4] mlr3tuning_1.4.0    paradox_1.0.1       mlr3torch_0.3.2    
##  [7] torch_0.16.3        future_1.67.0       mlr3pipelines_0.9.0
## [10] mlr3_1.2.0         
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6         xfun_0.54            processx_3.8.6      
##  [4] callr_3.7.6          vctrs_0.6.5          tools_4.5.1         
##  [7] ps_1.9.1             safetensors_0.2.0    parallel_4.5.1      
## [10] tibble_3.3.0         pkgconfig_2.0.3      data.table_1.17.8   
## [13] checkmate_2.3.3      RColorBrewer_1.1-3   S7_0.2.0            
## [16] assertthat_0.2.1     uuid_1.2-1           lifecycle_1.0.4     
## [19] compiler_4.5.1       farver_2.1.2         stringr_1.6.0       
## [22] precrec_0.14.5       codetools_0.2-20     bbotk_1.7.1         
## [25] pillar_1.11.1        crayon_1.5.3         rpart_4.1.24        
## [28] parallelly_1.45.1    digest_0.6.37        stringi_1.8.7       
## [31] listenv_0.10.0       labeling_0.4.3       mlr3measures_1.1.0  
## [34] rprojroot_2.1.1      grid_4.5.1           here_1.0.2          
## [37] cli_3.6.5            magrittr_2.0.4       future.apply_1.20.0 
## [40] withr_3.0.2          scales_1.4.0         backports_1.5.0     
## [43] rappdirs_0.3.3       bit64_4.6.0-1        globals_0.18.0      
## [46] jpeg_0.1-11          bit_4.6.0            evaluate_1.0.5      
## [49] knitr_1.50           torchvision_0.8.0    viridisLite_0.4.2   
## [52] mlr3misc_0.19.0      rlang_1.1.6          Rcpp_1.1.0          
## [55] zeallot_0.2.0        glue_1.8.0           renv_1.1.5          
## [58] palmerpenguins_0.1.1 coro_1.1.0           jsonlite_2.0.0      
## [61] lgr_0.5.0            R6_2.6.1             fs_1.6.6
</code></pre>
</div>
</body>
</html>
