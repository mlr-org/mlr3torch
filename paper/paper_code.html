<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-04 10:11:04 CET&quot;
</code></pre>
<pre><code class="language-r">options(mlr3torch.cache = TRUE)
lgr::get_logger('mlr3')$set_threshold('warn')
library(&quot;mlr3&quot;)
set.seed(42)
task &lt;- tsk(&quot;mtcars&quot;)
learner &lt;- lrn(&quot;regr.rpart&quot;)
split &lt;- partition(task, ratio = 2/3)
learner$train(task, split$train)
pred &lt;- learner$predict(task, split$test)
pred$score(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.736051
</code></pre>
<pre><code class="language-r">library(&quot;mlr3pipelines&quot;)
graph_learner &lt;- as_learner(po(&quot;pca&quot;) %&gt;&gt;% lrn(&quot;regr.rpart&quot;))

resampling &lt;- rsmp(&quot;cv&quot;, folds = 3)
rr &lt;- resample(task, graph_learner, resampling)
rr$aggregate(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.274766
</code></pre>
<pre><code class="language-r">library(&quot;torch&quot;)
torch_manual_seed(42)
x &lt;- torch_tensor(1, device = &quot;cpu&quot;)
w &lt;- torch_tensor(2, requires_grad = TRUE, device = &quot;cpu&quot;)
y &lt;- w * x
y$backward()
w$grad
</code></pre>
<pre><code>## torch_tensor
##  1
## [ CPUFloatType{1} ]
</code></pre>
<pre><code class="language-r">library(&quot;mlr3torch&quot;)
mnist &lt;- tsk(&quot;mnist&quot;)
mnist
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (70000x2): MNIST Digit Classification ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: label
</code></pre>
<pre><code>## Dataset &lt;mnist&gt; (~12 MB) will be downloaded and processed if not already available.
## Downloading &lt;mnist&gt; ...
## Processing &lt;mnist&gt;...
## Dataset &lt;mnist&gt; downloaded and extracted successfully.
## Dataset &lt;mnist&gt; loaded with 60000 images.
## Dataset &lt;mnist&gt; loaded with 10000 images.
</code></pre>
<pre><code>## • Target classes: 1 (11%), 7 (10%), 3 (10%), 2 (10%), 9 (10%), 0 (10%), 6 (10%), 8 (10%), 4 (10%), 5 (9%)
## • Properties: multiclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">rows &lt;- mnist$data(1:2)
rows
</code></pre>
<pre><code>##     label           image
##    &lt;fctr&gt;   &lt;lazy_tensor&gt;
## 1:      5 &lt;tnsr[1x28x28]&gt;
## 2:      0 &lt;tnsr[1x28x28]&gt;
</code></pre>
<pre><code class="language-r">str(materialize(rows$image))
</code></pre>
<pre><code>## List of 2
##  $ :Float [1:1, 1:28, 1:28]
##  $ :Float [1:1, 1:28, 1:28]
</code></pre>
<pre><code class="language-r">po_flat &lt;- po(&quot;trafo_reshape&quot;, shape = c(-1, 28 * 28))
mnist_flat &lt;- po_flat$train(list(mnist))[[1L]]
mnist_flat$head(2)
</code></pre>
<pre><code>##     label         image
##    &lt;fctr&gt; &lt;lazy_tensor&gt;
## 1:      5   &lt;tnsr[784]&gt;
## 2:      0   &lt;tnsr[784]&gt;
</code></pre>
<pre><code class="language-r">mlp &lt;- lrn(&quot;classif.mlp&quot;,
 loss = t_loss(&quot;cross_entropy&quot;),
 optimizer = t_opt(&quot;adamw&quot;, lr = 0.001),
 callbacks = t_clbk(&quot;history&quot;))

mlp$param_set$set_values(
  neurons = c(100, 200), activation = torch::nn_relu,
  p = 0.3, opt.weight_decay = 0.01, measures_train = msr(&quot;classif.logloss&quot;),
  epochs = 10, batch_size = 32, device = &quot;cpu&quot;)

mlp$configure(predict_type = &quot;prob&quot;)

mlp$train(mnist_flat, row_ids = 1:1001)

mlp$model$network
</code></pre>
<pre><code>## An `nn_module` containing 100,710 parameters.
## 
## ── Modules ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • 0: &lt;nn_linear&gt; #78,500 parameters
## • 1: &lt;nn_relu&gt; #0 parameters
## • 2: &lt;nn_dropout&gt; #0 parameters
## • 3: &lt;nn_linear&gt; #20,200 parameters
## • 4: &lt;nn_relu&gt; #0 parameters
## • 5: &lt;nn_dropout&gt; #0 parameters
## • 6: &lt;nn_linear&gt; #2,010 parameters
</code></pre>
<pre><code class="language-r">head(mlp$model$callbacks$history, n = 2)
</code></pre>
<pre><code>##    epoch train.classif.logloss
##    &lt;num&gt;                 &lt;num&gt;
## 1:     1              4.504887
## 2:     2              1.270129
</code></pre>
<pre><code class="language-r">pred &lt;- mlp$predict(mnist_flat, row_ids = 1001:1100)
pred$score(msr(&quot;classif.ce&quot;))
</code></pre>
<pre><code>## classif.ce 
##       0.19
</code></pre>
<pre><code class="language-r">pth &lt;- tempfile()
mlp$marshal()
saveRDS(mlp, pth)
mlp2 &lt;- readRDS(pth)
mlp2$unmarshal()

set_validate(mlp, validate = 0.3)

nn_simple &lt;- nn_module(&quot;nn_simple&quot;,
  initialize = function(d_in, d_latent, d_out) {
    self$linear1 = nn_linear(d_in, d_latent)
    self$activation = nn_relu()
    self$linear2 = nn_linear(d_latent, d_out)
  },
  forward = function(x) {
    x = self$linear1(x)
    x = self$activation(x)
    self$linear2(x)
  }
)

net &lt;- nn_simple(10, 100, 1)

net(torch_randn(1, 10))
</code></pre>
<pre><code>## torch_tensor
## 0.01 *
## -9.4603
## [ CPUFloatType{1,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">module_graph &lt;- po(&quot;module_1&quot;, module = nn_linear(10, 100)) %&gt;&gt;%
 po(&quot;module_2&quot;, module = nn_relu()) %&gt;&gt;%
 po(&quot;module_3&quot;, module = nn_linear(100, 1))

net &lt;- nn_graph(module_graph, shapes_in = list(module_1.input = c(NA, 10)))
net(torch_randn(2, 10))
</code></pre>
<pre><code>## torch_tensor
## -0.1218
## -0.0636
## [ CPUFloatType{2,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">graph &lt;- po(&quot;torch_ingress_ltnsr&quot;) %&gt;&gt;%
  nn(&quot;linear&quot;, out_features = 10) %&gt;&gt;% nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;head&quot;)

md &lt;- graph$train(mnist_flat)[[1L]]
print(&quot;a&quot;)
</code></pre>
<pre><code>## [1] &quot;a&quot;
</code></pre>
<pre><code class="language-r">md
</code></pre>
<pre><code>## &lt;ModelDescriptor: 4 ops&gt;
## * Ingress:  torch_ingress_ltnsr.input: [(NA,784)]
## * Task:  mnist [classif]
## * Callbacks:  N/A
## * Optimizer:  N/A
## * Loss:  N/A
## * pointer:  head.output [(NA,10)]
</code></pre>
<pre><code class="language-r">graph &lt;- graph %&gt;&gt;%
  po(&quot;torch_loss&quot;, t_loss(&quot;cross_entropy&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.001))

graph &lt;- graph %&gt;&gt;% po(&quot;torch_model_classif&quot;, epochs = 10, batch_size = 16)

glrn &lt;- as_learner(graph)
glrn$train(mnist_flat, row_ids = 1:1000)
print(&quot;b&quot;)
</code></pre>
<pre><code>## [1] &quot;b&quot;
</code></pre>
<pre><code class="language-r">path_lin &lt;- nn(&quot;linear_1&quot;)
path_nonlin &lt;- nn(&quot;linear_2&quot;) %&gt;&gt;% nn(&quot;relu&quot;)

residual_layer &lt;- list(path_lin, path_nonlin) %&gt;&gt;% nn(&quot;merge_sum&quot;)

path_num &lt;- po(&quot;select_1&quot;, selector = selector_type(&quot;numeric&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_num&quot;, d_token = 10)
path_categ &lt;- po(&quot;select_2&quot;, selector = selector_type(&quot;factor&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_categ&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_categ&quot;, d_token = 10)

graph &lt;- list(path_num, path_categ) %&gt;&gt;% nn(&quot;merge_cat&quot;, dim = 2)

blocks &lt;- nn(&quot;block&quot;, residual_layer, n_blocks = 5)

nn_winsorized_mse &lt;- nn_module(c(&quot;nn_winsorized_mse&quot;, &quot;nn_loss&quot;),
  initialize = function(max_loss) {
    self$max_loss &lt;- max_loss
  },
  forward = function(input, target) {
    torch_clamp(nnf_mse_loss(input, target), max = self$max_loss)
  }
)
tloss &lt;- as_torch_loss(nn_winsorized_mse)
tloss
</code></pre>
<pre><code>## &lt;TorchLoss:nn_winsorized_mse&gt; nn_winsorized_mse
## * Generator: nn_winsorized_mse
## * Parameters: list()
## * Packages: torch,mlr3torch
## * Task Types: classif,regr
</code></pre>
<pre><code class="language-r">gradient_clipper &lt;- torch_callback(&quot;gradient_clipper&quot;,
  initialize = function(max_norm, norm_type) {
    self$norms &lt;- numeric()
    self$max_norm &lt;- max_norm
    self$norm_type &lt;- norm_type
  },
  on_after_backward = function() {
    norm &lt;- nn_utils_clip_grad_norm_(self$ctx$network$parameters,
      self$max_norm, self$norm_type)
    self$norms &lt;- c(self$norms, norm$item())
  },
  state_dict = function() {
    self$norms
  },
  load_state_dict = function(state_dict) {
    self$norms = state_dict
  }
)

nn_ffn &lt;- nn_module(&quot;nn_ffn&quot;,
  initialize = function(task, latent_dim, n_layers) {
    dims &lt;- c(task$n_features, rep(latent_dim, n_layers),
      length(task$class_names))
    modules &lt;- unlist(lapply(seq_len(length(dims) - 1), function(i) {
      if (i &lt; length(dims) - 1) {
        list(nn_linear(dims[i], dims[i + 1]), nn_relu())
      } else {
        list(nn_linear(dims[i], dims[i + 1]))
      }
    }), recursive = FALSE)
    self$network &lt;- do.call(nn_sequential, modules)
  },
  forward = function(x) self$network(x)
)

num_input &lt;- list(x = ingress_num())
num_input
</code></pre>
<pre><code>## $x
## Ingress: Task[selector_type(c(&quot;numeric&quot;, &quot;integer&quot;))] --&gt; Tensor()
</code></pre>
<pre><code class="language-r">lrn_ffn &lt;- lrn(&quot;classif.module&quot;,
  module_generator = nn_ffn,
  ingress_tokens = num_input,
  latent_dim = 100, n_layers = 5)

task &lt;- tsk(&quot;mtcars&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskRegr&gt; (32x11): Motor Trends ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: mpg
## • Properties: -
## • Features (10):
##   • dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt
</code></pre>
<pre><code class="language-r">ingress &lt;- po(&quot;torch_ingress_num&quot;)

block &lt;- nn(&quot;linear&quot;, out_features = 32) %&gt;&gt;%
  ppl(&quot;branch&quot;, list(relu = nn(&quot;relu&quot;), sigmoid = nn(&quot;sigmoid&quot;))) %&gt;&gt;%
  nn(&quot;dropout&quot;)

architecture &lt;- nn(&quot;block&quot;, block) %&gt;&gt;% nn(&quot;head&quot;)

config &lt;- po(&quot;torch_loss&quot;, loss = t_loss(&quot;mse&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, optimizer = t_opt(&quot;adamw&quot;))

model &lt;- po(&quot;torch_model_regr&quot;, device = &quot;cpu&quot;, batch_size = 512)

pipeline &lt;- ingress %&gt;&gt;%
  architecture %&gt;&gt;% config %&gt;&gt;% model
learner &lt;- as_learner(pipeline)
learner$id &lt;- &quot;custom_nn&quot;

library(&quot;mlr3tuning&quot;)
</code></pre>
<pre><code>## Loading required package: paradox
</code></pre>
<pre><code class="language-r">learner$param_set$set_values(
  block.linear.out_features = to_tune(20, 500),
  block.n_blocks = to_tune(1, 5),
  block.branch.selection = to_tune(c(&quot;relu&quot;, &quot;sigmoid&quot;)),
  block.dropout.p = to_tune(0.1, 0.9),
  torch_optimizer.lr = to_tune(10^-4, 10^-1, logscale = TRUE))

set_validate(learner, &quot;test&quot;)

learner$param_set$set_values(
  torch_model_regr.patience = 5,
  torch_model_regr.measures_valid = msr(&quot;regr.mse&quot;),
  torch_model_regr.epochs = to_tune(upper = 100, internal = TRUE))

library(&quot;mlr3mbo&quot;)
ti &lt;- tune(
  tuner = tnr(&quot;mbo&quot;),
  resampling = rsmp(&quot;holdout&quot;),
  measure = msr(&quot;internal_valid_score&quot;, minimize = TRUE),
  learner = learner,
  term_evals = 30,
  task = task)
print(&quot;c&quot;)
</code></pre>
<pre><code>## [1] &quot;c&quot;
</code></pre>
<pre><code class="language-r">pvals &lt;- ti$result_learner_param_vals[2:6]
cat(paste(&quot;*&quot;, names(pvals), &quot;=&quot;, pvals,
 collapse = &quot;\n&quot;), &quot;\n&quot;)
</code></pre>
<pre><code>## * block.linear.out_features = 464
## * block.branch.selection = sigmoid
## * block.dropout.p = 0.375850691832602
## * torch_optimizer.lr = 0.00145715908440791
## * torch_model_regr.epochs = 100
</code></pre>
<pre><code class="language-r">library(&quot;torchdatasets&quot;)
dogs_vs_cats_dataset(&quot;data&quot;, download = TRUE)
</code></pre>
<pre><code>## &lt;dataset&gt;
##   Public:
##     .getitem: function (i) 
##     .length: function () 
##     classes: dog cat
##     clone: function (deep = FALSE) 
##     images: data/dogs-vs-cats/train/cat.0.jpg data/dogs-vs-cats/trai ...
##     initialize: function (root, split = &quot;train&quot;, download = FALSE, ..., transform = NULL, 
##     load_state_dict: function (x, ..., .refer_to_state_dict = FALSE) 
##     state_dict: function () 
##     target_transform: NULL
##     targets: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2  ...
##     transform: NULL
</code></pre>
<pre><code class="language-r">ds &lt;- torch::dataset(&quot;dogs_vs_cats&quot;,
  initialize = function(pths) {
    self$pths &lt;- pths
  },
  .getitem = function(i) {
    image &lt;- torchvision::base_loader(self$pths[i])
    list(image = torch_tensor(image)$permute(c(3, 1, 2)))
  },
  .length = function() {
    length(self$pths)
  }
)

paths &lt;- list.files(file.path(&quot;data&quot;, &quot;dogs-vs-cats/train&quot;),
  full.names = TRUE)
dogs_vs_cats &lt;- ds(paths)

lt &lt;- as_lazy_tensor(dogs_vs_cats, list(image = NULL))

labels &lt;- ifelse(grepl(&quot;dog\\.\\d+\\.jpg&quot;, paths), &quot;dog&quot;, &quot;cat&quot;)
table(labels)
</code></pre>
<pre><code>## labels
##   cat   dog 
## 12500 12500
</code></pre>
<pre><code class="language-r">tbl &lt;- data.table(image = lt, class = labels)
task &lt;- as_task_classif(tbl, target = &quot;class&quot;, id = &quot;dogs_vs_cats&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (25000x2) ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: class
## • Target classes: cat (positive class, 50%), dog (50%)
## • Properties: twoclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">augment &lt;- po(&quot;augment_random_vertical_flip&quot;, p = 0.5)

preprocess &lt;- po(&quot;trafo_resize&quot;, size = c(224, 224))

unfreezer &lt;- t_clbk(&quot;unfreeze&quot;,
  starting_weights = select_name(c(&quot;fc.weight&quot;, &quot;fc.bias&quot;)),
  unfreeze = data.table(epoch = 3, weights = select_all()))

resnet &lt;- lrn(&quot;classif.resnet18&quot;,
  pretrained = TRUE, epochs = 5, device = &quot;cpu&quot;, batch_size = 32,
  opt.lr = 1e-4, measures_valid = msr(&quot;classif.acc&quot;),
  callbacks = list(unfreezer, t_clbk(&quot;history&quot;)))

learner &lt;- as_learner(augment %&gt;&gt;% preprocess %&gt;&gt;% resnet)
learner$id &lt;- &quot;resnet&quot;
set_validate(learner, 1 / 3)
learner$train(task, c(12400:12600))
print(&quot;d&quot;)
</code></pre>
<pre><code>## [1] &quot;d&quot;
</code></pre>
<pre><code class="language-r">learner$model$classif.resnet18$model$callbacks$history
</code></pre>
<pre><code>##    epoch valid.classif.acc
##    &lt;num&gt;             &lt;num&gt;
## 1:     1         0.4776119
## 2:     2         0.5074627
## 3:     3         0.8955224
## 4:     4         0.9402985
## 5:     5         0.9701493
</code></pre>
<pre><code class="language-r">task &lt;- tsk(&quot;melanoma&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (32701x5): Melanoma Classification ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: outcome
## • Target classes: malignant (positive class, 2%), benign (98%)
## • Properties: twoclass, groups
## • Features (4):
##   • fct (2): anatom_site_general_challenge, sex
##   • int (1): age_approx
##   • lt (1): image
## • Groups: patient_id
</code></pre>
<pre><code class="language-r">table(task$truth())
</code></pre>
<pre><code>## 
## malignant    benign 
##       581     32120
</code></pre>
<pre><code class="language-r">task$missings(&quot;age_approx&quot;)
</code></pre>
<pre><code>## age_approx 
##         44
</code></pre>
<pre><code class="language-r">block_ffn &lt;- nn(&quot;linear&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;dropout&quot;)
path_tabular &lt;- po(&quot;select_1&quot;,
    selector = selector_type(c(&quot;integer&quot;, &quot;factor&quot;))) %&gt;&gt;%
  po(&quot;imputehist&quot;) %&gt;&gt;%
  po(&quot;encode&quot;, method = &quot;one-hot&quot;) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;block_1&quot;, block = block_ffn, n_blocks = 3)

path_image &lt;- po(&quot;select_2&quot;, selector = selector_name(&quot;image&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_ltnsr&quot;, shape = c(NA, 3, 128, 128)) %&gt;&gt;%
  nn(&quot;conv2d_1&quot;, out_channels = 16, kernel_size = 7, stride = 2,
    padding = 3) %&gt;&gt;%
  nn(&quot;batch_norm2d_1&quot;) %&gt;&gt;%
  nn(&quot;relu_1&quot;) %&gt;&gt;%
  nn(&quot;max_pool2d_1&quot;, kernel_size = 3, stride = 2, padding = 1) %&gt;&gt;%
  nn(&quot;conv2d_2&quot;, out_channels = 32, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_2&quot;) %&gt;&gt;%
  nn(&quot;relu_2&quot;) %&gt;&gt;%
  nn(&quot;conv2d_3&quot;, out_channels = 64, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_3&quot;) %&gt;&gt;%
  nn(&quot;relu_3&quot;) %&gt;&gt;%
  nn(&quot;flatten&quot;)

architecture &lt;- list(path_tabular, path_image) %&gt;&gt;%
  nn(&quot;merge_cat&quot;) %&gt;&gt;% nn(&quot;linear_1&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu_4&quot;) %&gt;&gt;% nn(&quot;dropout_2&quot;) %&gt;&gt;% nn(&quot;head&quot;)

model &lt;- architecture %&gt;&gt;%
  po(&quot;torch_loss&quot;,
    t_loss(&quot;cross_entropy&quot;, class_weight = torch_tensor(10))) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.0005)) %&gt;&gt;%
  po(&quot;torch_model_classif&quot;, epochs = 4, batch_size = 32, device = &quot;cpu&quot;,
    predict_type = &quot;prob&quot;)

preprocessing &lt;- po(&quot;classbalancing&quot;, ratio = 4, reference = &quot;minor&quot;,
    adjust = &quot;minor&quot;) %&gt;&gt;%
  po(&quot;augment_random_horizontal_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_vertical_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_crop&quot;, size = c(128, 128), pad_if_needed = TRUE)
glrn &lt;- as_learner(preprocessing %&gt;&gt;% model)

library(&quot;mlr3viz&quot;)
glrn$id &lt;- &quot;multimodal&quot;
task_subset &lt;- task$clone(deep = TRUE)
subset &lt;- partition(task_subset, ratio = 0.1)$train
task_subset$filter(subset)
rr &lt;- resample(task_subset, glrn, rsmp(&quot;holdout&quot;))
autoplot(rr, type = &quot;roc&quot;)
</code></pre>
<pre><code>## Warning in ggplot2::fortify(object, raw_curves = raw_curves, reduce_points = reduce_points): Arguments in `...` must be used.
## ✖ Problematic argument:
## • raw_curves = raw_curves
## ℹ Did you misspell an argument name?
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-1" /></p>
<pre><code class="language-r">saveRDS(.Last.value, here::here(&quot;paper&quot;, &quot;roc.rds&quot;))
sessionInfo()
</code></pre>
<pre><code>## R version 4.5.1 (2025-06-13)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sequoia 15.2
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: Europe/Berlin
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
##  [1] mlr3viz_0.10.1      torchdatasets_0.3.1 mlr3mbo_0.3.3      
##  [4] mlr3tuning_1.4.0    paradox_1.0.1       mlr3torch_0.3.2    
##  [7] torch_0.16.3        future_1.67.0       mlr3pipelines_0.9.0
## [10] mlr3_1.2.0         
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6         xfun_0.54            ggplot2_4.0.0       
##  [4] processx_3.8.6       lattice_0.22-7       callr_3.7.6         
##  [7] vctrs_0.6.5          tools_4.5.1          ps_1.9.1            
## [10] safetensors_0.2.0    curl_7.0.0           parallel_4.5.1      
## [13] tibble_3.3.0         pkgconfig_2.0.3      Matrix_1.7-3        
## [16] data.table_1.17.8    checkmate_2.3.3      RColorBrewer_1.1-3  
## [19] S7_0.2.0             assertthat_0.2.1     uuid_1.2-1          
## [22] lifecycle_1.0.4      farver_2.1.2         compiler_4.5.1      
## [25] stringr_1.5.2        precrec_0.14.5       codetools_0.2-20    
## [28] bbotk_1.7.1          pillar_1.11.1        crayon_1.5.3        
## [31] rpart_4.1.24         parallelly_1.45.1    digest_0.6.37       
## [34] stringi_1.8.7        listenv_0.10.0       labeling_0.4.3      
## [37] mlr3measures_1.1.0   rprojroot_2.1.1      grid_4.5.1          
## [40] here_1.0.2           cli_3.6.5            magrittr_2.0.4      
## [43] future.apply_1.20.0  withr_3.0.2          scales_1.4.0        
## [46] backports_1.5.0      rappdirs_0.3.3       bit64_4.6.0-1       
## [49] spacefillr_0.4.0     globals_0.18.0       jpeg_0.1-11         
## [52] bit_4.6.0            ranger_0.17.0        evaluate_1.0.5      
## [55] knitr_1.50           torchvision_0.7.0    viridisLite_0.4.2   
## [58] mlr3misc_0.19.0      rlang_1.1.6          Rcpp_1.1.0          
## [61] zeallot_0.2.0        glue_1.8.0           renv_1.1.5          
## [64] palmerpenguins_0.1.1 coro_1.1.0           jsonlite_2.0.0      
## [67] lgr_0.5.0            R6_2.6.1             fs_1.6.6            
## [70] mlr3learners_0.13.0
</code></pre>
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-04 10:23:47 CET&quot;
</code></pre>
</div>
</body>
</html>
