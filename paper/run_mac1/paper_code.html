<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 14:17:32 CET&quot;
</code></pre>
<pre><code class="language-r">options(mlr3torch.cache = TRUE)
lgr::get_logger('mlr3')$set_threshold('warn')
library(&quot;mlr3&quot;)
set.seed(42)
task &lt;- tsk(&quot;mtcars&quot;)
learner &lt;- lrn(&quot;regr.rpart&quot;)
split &lt;- partition(task, ratio = 2/3)
learner$train(task, split$train)
pred &lt;- learner$predict(task, split$test)
pred$score(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.736051
</code></pre>
<pre><code class="language-r">library(&quot;mlr3pipelines&quot;)
graph_learner &lt;- as_learner(po(&quot;pca&quot;) %&gt;&gt;% lrn(&quot;regr.rpart&quot;))

resampling &lt;- rsmp(&quot;cv&quot;, folds = 3)
rr &lt;- resample(task, graph_learner, resampling)
rr$aggregate(msr(&quot;regr.rmse&quot;))
</code></pre>
<pre><code>## regr.rmse 
##  4.274766
</code></pre>
<pre><code class="language-r">library(&quot;torch&quot;)
torch_manual_seed(42)
x &lt;- torch_tensor(1, device = &quot;cpu&quot;)
w &lt;- torch_tensor(2, requires_grad = TRUE, device = &quot;cpu&quot;)
y &lt;- w * x
y$backward()
w$grad
</code></pre>
<pre><code>## torch_tensor
##  1
## [ CPUFloatType{1} ]
</code></pre>
<pre><code class="language-r">library(&quot;mlr3torch&quot;)
mnist &lt;- tsk(&quot;mnist&quot;)
mnist
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (70000x2): MNIST Digit Classification ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: label
## • Target classes: 1 (11%), 7 (10%), 3 (10%), 2 (10%), 9 (10%), 0 (10%), 6 (10%), 8 (10%), 4 (10%), 5 (9%)
## • Properties: multiclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">rows &lt;- mnist$data(1:2)
rows
</code></pre>
<pre><code>##     label           image
##    &lt;fctr&gt;   &lt;lazy_tensor&gt;
## 1:      5 &lt;tnsr[1x28x28]&gt;
## 2:      0 &lt;tnsr[1x28x28]&gt;
</code></pre>
<pre><code class="language-r">str(materialize(rows$image))
</code></pre>
<pre><code>## List of 2
##  $ :Float [1:1, 1:28, 1:28]
##  $ :Float [1:1, 1:28, 1:28]
</code></pre>
<pre><code class="language-r">po_flat &lt;- po(&quot;trafo_reshape&quot;, shape = c(-1, 28 * 28))
mnist_flat &lt;- po_flat$train(list(mnist))[[1L]]
mnist_flat$head(2)
</code></pre>
<pre><code>##     label         image
##    &lt;fctr&gt; &lt;lazy_tensor&gt;
## 1:      5   &lt;tnsr[784]&gt;
## 2:      0   &lt;tnsr[784]&gt;
</code></pre>
<pre><code class="language-r">mlp &lt;- lrn(&quot;classif.mlp&quot;,
 loss = t_loss(&quot;cross_entropy&quot;),
 optimizer = t_opt(&quot;adamw&quot;, lr = 0.001),
 callbacks = t_clbk(&quot;history&quot;))

mlp$param_set$set_values(
  neurons = c(100, 200), activation = torch::nn_relu,
  p = 0.3, opt.weight_decay = 0.01, measures_train = msr(&quot;classif.logloss&quot;),
  epochs = 10, batch_size = 32, device = &quot;cpu&quot;)

mlp$configure(predict_type = &quot;prob&quot;)

mlp$train(mnist_flat, row_ids = 1:1001)

mlp$model$network
</code></pre>
<pre><code>## An `nn_module` containing 100,710 parameters.
## 
## ── Modules ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • 0: &lt;nn_linear&gt; #78,500 parameters
## • 1: &lt;nn_relu&gt; #0 parameters
## • 2: &lt;nn_dropout&gt; #0 parameters
## • 3: &lt;nn_linear&gt; #20,200 parameters
## • 4: &lt;nn_relu&gt; #0 parameters
## • 5: &lt;nn_dropout&gt; #0 parameters
## • 6: &lt;nn_linear&gt; #2,010 parameters
</code></pre>
<pre><code class="language-r">head(mlp$model$callbacks$history, n = 2)
</code></pre>
<pre><code>##    epoch train.classif.logloss
##    &lt;num&gt;                 &lt;num&gt;
## 1:     1              4.504887
## 2:     2              1.270129
</code></pre>
<pre><code class="language-r">pred &lt;- mlp$predict(mnist_flat, row_ids = 1001:1100)
pred$score(msr(&quot;classif.ce&quot;))
</code></pre>
<pre><code>## classif.ce 
##       0.19
</code></pre>
<pre><code class="language-r">pth &lt;- tempfile()
mlp$marshal()
saveRDS(mlp, pth)
mlp2 &lt;- readRDS(pth)
mlp2$unmarshal()

set_validate(mlp, validate = 0.3)

nn_simple &lt;- nn_module(&quot;nn_simple&quot;,
  initialize = function(d_in, d_latent, d_out) {
    self$linear1 = nn_linear(d_in, d_latent)
    self$activation = nn_relu()
    self$linear2 = nn_linear(d_latent, d_out)
  },
  forward = function(x) {
    x = self$linear1(x)
    x = self$activation(x)
    self$linear2(x)
  }
)

net &lt;- nn_simple(10, 100, 1)

net(torch_randn(1, 10))
</code></pre>
<pre><code>## torch_tensor
## 0.01 *
## -9.4603
## [ CPUFloatType{1,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">module_graph &lt;- po(&quot;module_1&quot;, module = nn_linear(10, 100)) %&gt;&gt;%
 po(&quot;module_2&quot;, module = nn_relu()) %&gt;&gt;%
 po(&quot;module_3&quot;, module = nn_linear(100, 1))

net &lt;- nn_graph(module_graph, shapes_in = list(module_1.input = c(NA, 10)))
net(torch_randn(2, 10))
</code></pre>
<pre><code>## torch_tensor
## -0.1218
## -0.0636
## [ CPUFloatType{2,1} ][ grad_fn = &lt;AddmmBackward0&gt; ]
</code></pre>
<pre><code class="language-r">graph &lt;- po(&quot;torch_ingress_ltnsr&quot;) %&gt;&gt;%
  nn(&quot;linear&quot;, out_features = 10) %&gt;&gt;% nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;head&quot;)

md &lt;- graph$train(mnist_flat)[[1L]]
md
</code></pre>
<pre><code>## &lt;ModelDescriptor: 4 ops&gt;
## * Ingress:  torch_ingress_ltnsr.input: [(NA,784)]
## * Task:  mnist [classif]
## * Callbacks:  N/A
## * Optimizer:  N/A
## * Loss:  N/A
## * pointer:  head.output [(NA,10)]
</code></pre>
<pre><code class="language-r">graph &lt;- graph %&gt;&gt;%
  po(&quot;torch_loss&quot;, t_loss(&quot;cross_entropy&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.001))

graph &lt;- graph %&gt;&gt;% po(&quot;torch_model_classif&quot;, epochs = 10, batch_size = 16)

glrn &lt;- as_learner(graph)
glrn$train(mnist_flat, row_ids = 1:1000)

path_lin &lt;- nn(&quot;linear_1&quot;)
path_nonlin &lt;- nn(&quot;linear_2&quot;) %&gt;&gt;% nn(&quot;relu&quot;)

residual_layer &lt;- list(path_lin, path_nonlin) %&gt;&gt;% nn(&quot;merge_sum&quot;)

path_num &lt;- po(&quot;select_1&quot;, selector = selector_type(&quot;numeric&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_num&quot;, d_token = 10)
path_categ &lt;- po(&quot;select_2&quot;, selector = selector_type(&quot;factor&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_categ&quot;) %&gt;&gt;%
  nn(&quot;tokenizer_categ&quot;, d_token = 10)

graph &lt;- list(path_num, path_categ) %&gt;&gt;% nn(&quot;merge_cat&quot;, dim = 2)

blocks &lt;- nn(&quot;block&quot;, residual_layer, n_blocks = 5)

nn_winsorized_mse &lt;- nn_module(c(&quot;nn_winsorized_mse&quot;, &quot;nn_loss&quot;),
  initialize = function(max_loss) {
    self$max_loss &lt;- max_loss
  },
  forward = function(input, target) {
    torch_clamp(nnf_mse_loss(input, target), max = self$max_loss)
  }
)
tloss &lt;- as_torch_loss(nn_winsorized_mse)
tloss
</code></pre>
<pre><code>## &lt;TorchLoss:nn_winsorized_mse&gt; nn_winsorized_mse
## * Generator: nn_winsorized_mse
## * Parameters: list()
## * Packages: torch,mlr3torch
## * Task Types: classif,regr
</code></pre>
<pre><code class="language-r">gradient_clipper &lt;- torch_callback(&quot;gradient_clipper&quot;,
  initialize = function(max_norm, norm_type) {
    self$norms &lt;- numeric()
    self$max_norm &lt;- max_norm
    self$norm_type &lt;- norm_type
  },
  on_after_backward = function() {
    norm &lt;- nn_utils_clip_grad_norm_(self$ctx$network$parameters,
      self$max_norm, self$norm_type)
    self$norms &lt;- c(self$norms, norm$item())
  },
  state_dict = function() {
    self$norms
  },
  load_state_dict = function(state_dict) {
    self$norms = state_dict
  }
)

nn_ffn &lt;- nn_module(&quot;nn_ffn&quot;,
  initialize = function(task, latent_dim, n_layers) {
    dims &lt;- c(task$n_features, rep(latent_dim, n_layers),
      length(task$class_names))
    modules &lt;- unlist(lapply(seq_len(length(dims) - 1), function(i) {
      if (i &lt; length(dims) - 1) {
        list(nn_linear(dims[i], dims[i + 1]), nn_relu())
      } else {
        list(nn_linear(dims[i], dims[i + 1]))
      }
    }), recursive = FALSE)
    self$network &lt;- do.call(nn_sequential, modules)
  },
  forward = function(x) self$network(x)
)

num_input &lt;- list(x = ingress_num())
num_input
</code></pre>
<pre><code>## $x
## Ingress: Task[selector_type(c(&quot;numeric&quot;, &quot;integer&quot;))] --&gt; Tensor()
</code></pre>
<pre><code class="language-r">lrn_ffn &lt;- lrn(&quot;classif.module&quot;,
  module_generator = nn_ffn,
  ingress_tokens = num_input,
  latent_dim = 100, n_layers = 5)

task &lt;- tsk(&quot;mtcars&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskRegr&gt; (32x11): Motor Trends ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: mpg
## • Properties: -
## • Features (10):
##   • dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt
</code></pre>
<pre><code class="language-r">ingress &lt;- po(&quot;torch_ingress_num&quot;)

block &lt;- nn(&quot;linear&quot;, out_features = 32) %&gt;&gt;%
  ppl(&quot;branch&quot;, list(relu = nn(&quot;relu&quot;), sigmoid = nn(&quot;sigmoid&quot;))) %&gt;&gt;%
  nn(&quot;dropout&quot;)

architecture &lt;- nn(&quot;block&quot;, block) %&gt;&gt;% nn(&quot;head&quot;)

config &lt;- po(&quot;torch_loss&quot;, loss = t_loss(&quot;mse&quot;)) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, optimizer = t_opt(&quot;adamw&quot;))

model &lt;- po(&quot;torch_model_regr&quot;, device = &quot;cpu&quot;, batch_size = 512)

pipeline &lt;- ingress %&gt;&gt;%
  architecture %&gt;&gt;% config %&gt;&gt;% model
learner &lt;- as_learner(pipeline)
learner$id &lt;- &quot;custom_nn&quot;

library(&quot;mlr3tuning&quot;)
</code></pre>
<pre><code>## Loading required package: paradox
</code></pre>
<pre><code class="language-r">learner$param_set$set_values(
  block.linear.out_features = to_tune(20, 500),
  block.n_blocks = to_tune(1, 5),
  block.branch.selection = to_tune(c(&quot;relu&quot;, &quot;sigmoid&quot;)),
  block.dropout.p = to_tune(0.1, 0.9),
  torch_optimizer.lr = to_tune(10^-4, 10^-1, logscale = TRUE))

set_validate(learner, &quot;test&quot;)

learner$param_set$set_values(
  torch_model_regr.patience = 5,
  torch_model_regr.measures_valid = msr(&quot;regr.mse&quot;),
  torch_model_regr.epochs = to_tune(upper = 100, internal = TRUE))

library(&quot;mlr3tuning&quot;)
ti &lt;- tune(
  tuner = tnr(&quot;random_search&quot;),
  resampling = rsmp(&quot;holdout&quot;),
  measure = msr(&quot;internal_valid_score&quot;, minimize = TRUE),
  learner = learner,
  term_evals = 30,
  task = task)
pvals &lt;- ti$result_learner_param_vals[2:6]
cat(paste(&quot;*&quot;, names(pvals), &quot;=&quot;, pvals,
 collapse = &quot;\n&quot;), &quot;\n&quot;)
</code></pre>
<pre><code>## * block.linear.out_features = 248
## * block.branch.selection = sigmoid
## * block.dropout.p = 0.861211954243481
## * torch_optimizer.lr = 0.00310737353560635
## * torch_model_regr.epochs = 44
</code></pre>
<pre><code class="language-r">library(&quot;torchdatasets&quot;)
dogs_vs_cats_dataset(&quot;data&quot;, download = TRUE)
</code></pre>
<pre><code>## &lt;dataset&gt;
##   Public:
##     .getitem: function (i) 
##     .length: function () 
##     classes: dog cat
##     clone: function (deep = FALSE) 
##     images: data/dogs-vs-cats/train/cat.0.jpg data/dogs-vs-cats/trai ...
##     initialize: function (root, split = &quot;train&quot;, download = FALSE, ..., transform = NULL, 
##     load_state_dict: function (x, ..., .refer_to_state_dict = FALSE) 
##     state_dict: function () 
##     target_transform: NULL
##     targets: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2  ...
##     transform: NULL
</code></pre>
<pre><code class="language-r">ds &lt;- torch::dataset(&quot;dogs_vs_cats&quot;,
  initialize = function(pths) {
    self$pths &lt;- pths
  },
  .getitem = function(i) {
    image &lt;- torchvision::base_loader(self$pths[i])
    list(image = torch_tensor(image)$permute(c(3, 1, 2)))
  },
  .length = function() {
    length(self$pths)
  }
)

paths &lt;- list.files(file.path(&quot;data&quot;, &quot;dogs-vs-cats/train&quot;),
  full.names = TRUE)
dogs_vs_cats &lt;- ds(paths)

lt &lt;- as_lazy_tensor(dogs_vs_cats, list(image = NULL))

labels &lt;- ifelse(grepl(&quot;dog\\.\\d+\\.jpg&quot;, paths), &quot;dog&quot;, &quot;cat&quot;)
table(labels)
</code></pre>
<pre><code>## labels
##   cat   dog 
## 12500 12500
</code></pre>
<pre><code class="language-r">tbl &lt;- data.table(image = lt, class = labels)
task &lt;- as_task_classif(tbl, target = &quot;class&quot;, id = &quot;dogs_vs_cats&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (25000x2) ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: class
## • Target classes: cat (positive class, 50%), dog (50%)
## • Properties: twoclass
## • Features (1):
##   • lt (1): image
</code></pre>
<pre><code class="language-r">augment &lt;- po(&quot;augment_random_vertical_flip&quot;, p = 0.5)

preprocess &lt;- po(&quot;trafo_resize&quot;, size = c(224, 224))

unfreezer &lt;- t_clbk(&quot;unfreeze&quot;,
  starting_weights = select_name(c(&quot;fc.weight&quot;, &quot;fc.bias&quot;)),
  unfreeze = data.table(epoch = 3, weights = select_all()))

resnet &lt;- lrn(&quot;classif.resnet18&quot;,
  pretrained = TRUE, epochs = 5, device = &quot;cpu&quot;, batch_size = 32,
  opt.lr = 1e-4, measures_valid = msr(&quot;classif.acc&quot;),
  callbacks = list(unfreezer, t_clbk(&quot;history&quot;)))

learner &lt;- as_learner(augment %&gt;&gt;% preprocess %&gt;&gt;% resnet)
learner$id &lt;- &quot;resnet&quot;
set_validate(learner, 1 / 3)
learner$train(task, c(12400:12600))
</code></pre>
<pre><code>## Model weights for &lt;resnet18&gt; (~45 MB) will be downloaded and processed if not
## already available.
</code></pre>
<pre><code class="language-r">learner$model$classif.resnet18$model$callbacks$history
</code></pre>
<pre><code>##    epoch valid.classif.acc
##    &lt;num&gt;             &lt;num&gt;
## 1:     1         0.4179104
## 2:     2         0.4626866
## 3:     3         0.8955224
## 4:     4         0.8955224
## 5:     5         0.9253731
</code></pre>
<pre><code class="language-r">task &lt;- tsk(&quot;melanoma&quot;)
task
</code></pre>
<pre><code>## 
## ── &lt;TaskClassif&gt; (32701x5): Melanoma Classification ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
## • Target: outcome
## • Target classes: malignant (positive class, 2%), benign (98%)
## • Properties: twoclass, groups
## • Features (4):
##   • fct (2): anatom_site_general_challenge, sex
##   • int (1): age_approx
##   • lt (1): image
## • Groups: patient_id
</code></pre>
<pre><code class="language-r">table(task$truth())
</code></pre>
<pre><code>## 
## malignant    benign 
##       581     32120
</code></pre>
<pre><code class="language-r">task$missings(&quot;age_approx&quot;)
</code></pre>
<pre><code>## age_approx 
##         44
</code></pre>
<pre><code class="language-r">block_ffn &lt;- nn(&quot;linear&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu&quot;) %&gt;&gt;% nn(&quot;dropout&quot;)
path_tabular &lt;- po(&quot;select_1&quot;,
    selector = selector_type(c(&quot;integer&quot;, &quot;factor&quot;))) %&gt;&gt;%
  po(&quot;imputehist&quot;) %&gt;&gt;%
  po(&quot;encode&quot;, method = &quot;one-hot&quot;) %&gt;&gt;%
  po(&quot;torch_ingress_num&quot;) %&gt;&gt;%
  nn(&quot;block_1&quot;, block = block_ffn, n_blocks = 3)

path_image &lt;- po(&quot;select_2&quot;, selector = selector_name(&quot;image&quot;)) %&gt;&gt;%
  po(&quot;torch_ingress_ltnsr&quot;, shape = c(NA, 3, 128, 128)) %&gt;&gt;%
  nn(&quot;conv2d_1&quot;, out_channels = 16, kernel_size = 7, stride = 2,
    padding = 3) %&gt;&gt;%
  nn(&quot;batch_norm2d_1&quot;) %&gt;&gt;%
  nn(&quot;relu_1&quot;) %&gt;&gt;%
  nn(&quot;max_pool2d_1&quot;, kernel_size = 3, stride = 2, padding = 1) %&gt;&gt;%
  nn(&quot;conv2d_2&quot;, out_channels = 32, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_2&quot;) %&gt;&gt;%
  nn(&quot;relu_2&quot;) %&gt;&gt;%
  nn(&quot;conv2d_3&quot;, out_channels = 64, kernel_size = 3, stride = 1,
    padding = 1) %&gt;&gt;%
  nn(&quot;batch_norm2d_3&quot;) %&gt;&gt;%
  nn(&quot;relu_3&quot;) %&gt;&gt;%
  nn(&quot;flatten&quot;)

architecture &lt;- list(path_tabular, path_image) %&gt;&gt;%
  nn(&quot;merge_cat&quot;) %&gt;&gt;% nn(&quot;linear_1&quot;, out_features = 500) %&gt;&gt;%
  nn(&quot;relu_4&quot;) %&gt;&gt;% nn(&quot;dropout_2&quot;) %&gt;&gt;% nn(&quot;head&quot;)

model &lt;- architecture %&gt;&gt;%
  po(&quot;torch_loss&quot;,
    t_loss(&quot;cross_entropy&quot;, class_weight = torch_tensor(10))) %&gt;&gt;%
  po(&quot;torch_optimizer&quot;, t_opt(&quot;adamw&quot;, lr = 0.0005)) %&gt;&gt;%
  po(&quot;torch_model_classif&quot;, epochs = 4, batch_size = 32, device = &quot;cpu&quot;,
    predict_type = &quot;prob&quot;)

preprocessing &lt;- po(&quot;classbalancing&quot;, ratio = 4, reference = &quot;minor&quot;,
    adjust = &quot;minor&quot;) %&gt;&gt;%
  po(&quot;augment_random_horizontal_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_vertical_flip&quot;) %&gt;&gt;%
  po(&quot;augment_random_crop&quot;, size = c(128, 128), pad_if_needed = TRUE)
glrn &lt;- as_learner(preprocessing %&gt;&gt;% model)

library(&quot;mlr3viz&quot;)
glrn$id &lt;- &quot;multimodal&quot;
task_subset &lt;- task$clone(deep = TRUE)
subset &lt;- partition(task_subset, ratio = 0.1)$train
task_subset$filter(subset)
rr &lt;- resample(task_subset, glrn, rsmp(&quot;holdout&quot;))
autoplot(rr, type = &quot;roc&quot;)
</code></pre>
<pre><code>## Warning in ggplot2::fortify(object, raw_curves = raw_curves, reduce_points = reduce_points): Arguments in `...` must be used.
## ✖ Problematic argument:
## • raw_curves = raw_curves
## ℹ Did you misspell an argument name?
</code></pre>
<p><img src="data:image/png;base64,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traaDRs2mMWLF5vhw4fb8/bv32/27Nljzj33XEbtlwK6zHML8W5razObN282Z599tmloaLAtbNq0qSeD4ezZs82wYcPKbJnLiiFQSD+7d+82R48etdVMmDDB6C/XZ6qYdjinPAL5eB87dszs2rWrp1J9v+nzkktnPSexEQmBffv22e+vsWPH9qpfmViVkXXKlClm4sSJ9liufb0uKvNN3V8HpcxrY3vZ/fffbw3EL3/5SyNjsXDhwh5ZDx8+bD7xiU9YA/GNb3zDvPnNbzZr1qwx2ta5P/zhD82yZct6zmfDPYFnnnkmL299OX3qU58yY8aMMf/4j/9oLrnkEivAX/zFX9jXnTt3mlmzZpmRI0e6F4waLYFC+tEJn/zkJ83JkyeNdCEDokWf+n6m6uu99R1qfpfk+g4LecuQ//SnP7W60XfZ9u3bzRve8IZ+Ops6dWrN++GzANLDRz/6UZuYbfr06T1d1aS1v/qrv7LZWB977DHrZOq7ru++vj8KeiooccPLT6EM9j333GM9vptvvtksX768B8sPfvAD8+53v9saDiXR+Z//+R/z/e9/39xxxx3WaHzsYx8z+hXc3Nzccw0bbgl8+9vfzsv74MGD5pZbbjHz5s2zevjNb35j9AF5/etfb6699lpr+N1KQ219CRTSjz4zKu95z3uscVeOim9+85v9PlPhD7O+dfO+cgK5vsNC3nPnzjU33XST/QGm77IPfehDJpfOKpeCGvIR6OzsNF/96lfNOeec0++UjRs3Ws/9uuuuM0uXLjVPPvmk+YM/+IN++/Qd6KJ49wy+paXFjBo1yrLRr9q+GfAUhldoRGXSpElGYRSFG0OPUCEThScp0REoxPv888+3xl16/PnPf270XuH65557zjzwwAPmz//8z204ODrpqLmQfl566SUb7n3ooYfMn/3Zn9lQY67PFBSjI1AM73/91381b33rW+33Wi6dRScdNWu9lM9+9rM9diabSC7d5dqXfU0l29558PIowl+sAhOGrkJIymcfHpfxb2xsDA/ZVz0L6buv1wm8cUogF2958Xfeeac1IOPHj7dfVH/4h39oFxp64oknzI9//GPz9re/3akcVJabQF/9KJryT//0T/YRl8a5/Mu//IuNdhX6TOWumb3lEhjoO0y60I9jPeJSyaWzXN5lufJwXfEEcuku177iayx8pncevELr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" alt="plot of chunk unnamed-chunk-1" /></p>
<pre><code class="language-r">saveRDS(.Last.value, here::here(&quot;paper&quot;, &quot;roc.rds&quot;))
sessionInfo()
</code></pre>
<pre><code>## R version 4.5.1 (2025-06-13)
## Platform: aarch64-apple-darwin20
## Running under: macOS Sequoia 15.2
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib 
## LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## time zone: Europe/Berlin
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices datasets  utils     methods   base     
## 
## other attached packages:
## [1] mlr3viz_0.10.1      torchdatasets_0.3.1 mlr3tuning_1.4.0   
## [4] paradox_1.0.1       mlr3torch_0.3.2     torch_0.16.3       
## [7] future_1.67.0       mlr3pipelines_0.9.0 mlr3_1.2.0         
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6         xfun_0.54            ggplot2_4.0.0       
##  [4] processx_3.8.6       callr_3.7.6          vctrs_0.6.5         
##  [7] tools_4.5.1          ps_1.9.1             safetensors_0.2.0   
## [10] parallel_4.5.1       tibble_3.3.0         pkgconfig_2.0.3     
## [13] data.table_1.17.8    checkmate_2.3.3      RColorBrewer_1.1-3  
## [16] S7_0.2.0             assertthat_0.2.1     uuid_1.2-1          
## [19] lifecycle_1.0.4      compiler_4.5.1       farver_2.1.2        
## [22] stringr_1.6.0        precrec_0.14.5       codetools_0.2-20    
## [25] bbotk_1.7.1          pillar_1.11.1        crayon_1.5.3        
## [28] rpart_4.1.24         parallelly_1.45.1    digest_0.6.37       
## [31] stringi_1.8.7        listenv_0.10.0       labeling_0.4.3      
## [34] mlr3measures_1.1.0   rprojroot_2.1.1      grid_4.5.1          
## [37] here_1.0.2           cli_3.6.5            magrittr_2.0.4      
## [40] future.apply_1.20.0  withr_3.0.2          scales_1.4.0        
## [43] backports_1.5.0      rappdirs_0.3.3       bit64_4.6.0-1       
## [46] globals_0.18.0       jpeg_0.1-11          bit_4.6.0           
## [49] evaluate_1.0.5       knitr_1.50           torchvision_0.8.0   
## [52] viridisLite_0.4.2    mlr3misc_0.19.0      rlang_1.1.6         
## [55] Rcpp_1.1.0           zeallot_0.2.0        glue_1.8.0          
## [58] renv_1.1.5           palmerpenguins_0.1.1 coro_1.1.0          
## [61] jsonlite_2.0.0       lgr_0.5.0            R6_2.6.1            
## [64] fs_1.6.6
</code></pre>
<pre><code class="language-r">Sys.time()
</code></pre>
<pre><code>## [1] &quot;2025-11-06 14:25:04 CET&quot;
</code></pre>
</div>
</body>
</html>
