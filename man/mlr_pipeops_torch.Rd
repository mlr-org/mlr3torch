% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpTorch.R
\name{mlr_pipeops_torch}
\alias{mlr_pipeops_torch}
\alias{PipeOpTorch}
\title{Base Class for Torch Module Constructor Wrappers}
\format{
\code{\link{R6Class}} object inheriting from \code{\link{PipeOpTaskPreproc}}/\code{\link{PipeOp}}.
}
\description{
\code{PipeOpTorch} wraps a \code{torch::nn_module_generator}. It builds an isomorphic \code{Graph} and also keeps track of the
tensor shape(s) involved.
}
\section{Input and Output Channels}{


During training, all input channels take in a \link{ModelDescriptor} and output a \link{ModelDescriptor}.
During prediction, all input channels take in a \link[mlr3:Task]{mlr3::Task} and output the same \link[mlr3:Task]{mlr3::Task}.

The generated \link{PipeOpModule} has exactly the same input and output channels.
The names of the input channels correspond to the argument names of the generated \code{nn_module}.
The output channels should correspond to the

The output is the input \code{\link[mlr3:Task]{Task}} with all affected numeric features replaced by their
non-negative components.
}

\section{Inheriting}{

When inheriting from this class, one should overload the \code{private$.shapes_out()} and the \verb{private$.shape_dependent_ params()} methods.

\code{private$.shapes_out()} gets a list of \code{numeric} vectors as input. This list indicates the shape of input tensors
that will be fed to the module's \verb{$forward()} function. The list has one item per input tensor, typically only one.
The shape vectors may contain \code{NA} entries indicating arbitrary size (typically used for the batch dimension). The
function should return a list of shapes of tensors that are created by the module. If \code{multi_output} is \code{NULL} it
should be of length 1. If \code{multi_output} is an \code{integer(1)}, then this should be the sgraph = ame length as the return value
of the module's \verb{$forward()}.

\code{private$.shape_dependent_params()} calculates construction arguments of \code{module_generator} that depend on the input shape.
It should return a named list.

It is possible to overload \code{private$.make_module()} instead of \code{private$.shape_dependent_params()}, in which case it is even allowed
to not give a \code{module_generator} during construction.
}

\section{Super class}{
\code{\link[mlr3pipelines:PipeOp]{mlr3pipelines::PipeOp}} -> \code{PipeOpTorch}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PipeOpTorch-new}{\code{PipeOpTorch$new()}}
\item \href{#method-PipeOpTorch-shapes_out}{\code{PipeOpTorch$shapes_out()}}
\item \href{#method-PipeOpTorch-clone}{\code{PipeOpTorch$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpTorch-new"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpTorch-new}{}}}
\subsection{Method \code{new()}}{
Initializes a new instance of this \link[R6:R6Class]{R6 Class}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpTorch$new(
  id,
  module_generator,
  param_set = ps(),
  param_vals = list(),
  inname = NULL,
  outname = "output",
  packages = "torch"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{(\code{character(1)})\cr
The id for of the new object.}

\item{\code{module_generator}}{(\code{nn_module_generator} | \code{NULL})\cr
When this is \code{NULL}, then \code{private$.make_module} must be overloaded.}

\item{\code{param_set}}{(\code{paradox::ParamSet})\cr
The parameter set.}

\item{\code{param_vals}}{(named \code{list()})\cr
The initial parameters for the object.}

\item{\code{inname}}{(\code{character()} or \code{NULL})\cr
The names of the \link{PipeOp}'s input channels.
If \code{module_generator} is not \code{NULL}, they must be a permutation of the argument names of the module's \code{forward}
function. This is also the default behaviour
inferred from the forward function of the module generator.
Otherwise this can be a character vector giving the names, or an integer \code{n}, such that the
names are \verb{input1, input2, ..., input<n>}.}

\item{\code{outname}}{(\code{character()}) \cr
The names of the \link{PipeOp}'s output channels channels.
The default is \code{"output"}.
In case there is more than one output channel, the \code{nn_module} that is constructed by this
\link{PipeOp} during training must return a named list, where the names of the list are the
names out the output channels. When providing an integer \code{n}, the names are set to
\verb{input1, input2, ..., input<n>}.}

\item{\code{packages}}{(\code{character()})\cr
The R packages this \link{PipeOP} depends on.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpTorch-shapes_out"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpTorch-shapes_out}{}}}
\subsection{Method \code{shapes_out()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpTorch$shapes_out(shapes_in)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpTorch-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpTorch-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpTorch$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
