% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataBackendLazyTensors.R
\name{DataBackendLazyTensors}
\alias{DataBackendLazyTensors}
\title{Special Backend for Lazy Tensors}
\description{
This backend essentially allows you to use a \code{\link[torch:dataset]{torch::dataset}} directly with
an \code{\link[mlr3:Learner]{mlr3::Learner}}.
\itemize{
\item The data cannot contain missing values, as \code{\link{lazy_tensor}}s do not support them.
For this reason, calling \verb{$missings()} will always return \code{0} for all columns.
\item The \verb{$distinct()} method will consider two lazy tensors that refer to the same element of a
\code{\link{DataDescriptor}} to be identical.
This means, that it might be underreporting the number of distinct values of lazy tensor columns.
}
}
\examples{
\dontshow{if (torch::torch_is_installed()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
# used as feature in all backends
x = torch_randn(100, 10)
# regression
ds_regr = tensor_dataset(x = x, y = torch_randn(100, 1))
be_regr = as_data_backend(ds_regr, converter = list(y = as.numeric))
be_regr$head()


# binary classification: underlying target tensor must be float in [0, 1]
ds_binary = tensor_dataset(x = x, y = torch_randint(0, 2, c(100, 1))$float())
be_binary = as_data_backend(ds_binary, converter = list(
  y = function(x) factor(as.integer(x), levels = c(0, 1), labels = c("A", "yes"))
))
be_binary$head()

# multi-class classification: underlying target tensor must be integer in [1, K]
ds_multiclass = tensor_dataset(x = x, y = torch_randint(1, 4, size = c(100, 1)))
be_multiclass = as_data_backend(ds_multiclass, converter = list(y = as.numeric))
be_multiclass$head()
\dontshow{\}) # examplesIf}
}
\section{Super classes}{
\code{\link[mlr3:DataBackend]{mlr3::DataBackend}} -> \code{\link[mlr3:DataBackendDataTable]{mlr3::DataBackendDataTable}} -> \code{DataBackendLazyTensors}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-DataBackendLazyTensors-new}{\code{DataBackendLazyTensors$new()}}
\item \href{#method-DataBackendLazyTensors-data}{\code{DataBackendLazyTensors$data()}}
\item \href{#method-DataBackendLazyTensors-head}{\code{DataBackendLazyTensors$head()}}
\item \href{#method-DataBackendLazyTensors-missings}{\code{DataBackendLazyTensors$missings()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-format'><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href='../../mlr3/html/DataBackend.html#method-DataBackend-print'><code>mlr3::DataBackend$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackendDataTable" data-id="distinct"><a href='../../mlr3/html/DataBackendDataTable.html#method-DataBackendDataTable-distinct'><code>mlr3::DataBackendDataTable$distinct()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataBackendLazyTensors-new"></a>}}
\if{latex}{\out{\hypertarget{method-DataBackendLazyTensors-new}{}}}
\subsection{Method \code{new()}}{
Create a new instance of this \link[R6:R6Class]{R6} class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendLazyTensors$new(
  data,
  primary_key,
  converter,
  cache = names(converter),
  chunk_size = 100
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{(\code{data.table})\cr
Data containing (among others) \code{\link{lazy_tensor}} columns.}

\item{\code{primary_key}}{(\code{character(1)})\cr
Name of the column used as primary key.}

\item{\code{converter}}{(named \code{list()} of \code{function}s)\cr
A named list of functions that convert the lazy tensor columns to their R representation.
The names must be the names of the columns that need conversion.}

\item{\code{cache}}{(\code{character()})\cr
Names of the columns that should be cached.
Per default, all columns that are converted are cached.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataBackendLazyTensors-data"></a>}}
\if{latex}{\out{\hypertarget{method-DataBackendLazyTensors-data}{}}}
\subsection{Method \code{data()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendLazyTensors$data(rows, cols)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataBackendLazyTensors-head"></a>}}
\if{latex}{\out{\hypertarget{method-DataBackendLazyTensors-head}{}}}
\subsection{Method \code{head()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendLazyTensors$head(n = 6L)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-DataBackendLazyTensors-missings"></a>}}
\if{latex}{\out{\hypertarget{method-DataBackendLazyTensors-missings}{}}}
\subsection{Method \code{missings()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataBackendLazyTensors$missings(rows, cols)}\if{html}{\out{</div>}}
}

}
}
